var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __require = typeof require !== "undefined" ? require : (x) => {
  throw new Error('Dynamic require of "' + x + '" is not supported');
};

// src/label-parser.ts
import {
  arrowFunctionExpression as arrowFunctionExpression4,
  callExpression as callExpression8,
  identifier as identifier4,
  isArrayPattern as isArrayPattern3,
  isAssignmentExpression,
  isBlockStatement,
  isExpressionStatement,
  isIdentifier as isIdentifier5,
  isLabeledStatement as isLabeledStatement2,
  isObjectPattern as isObjectPattern2,
  isSequenceExpression,
  isVariableDeclaration,
  objectExpression as objectExpression4,
  objectProperty as objectProperty5,
  stringLiteral as stringLiteral5,
  variableDeclaration as variableDeclaration2,
  variableDeclarator as variableDeclarator3
} from "@babel/types";

// src/get-hook-identifier.ts
import { addNamed } from "@babel/helper-module-imports";
function getHookIdentifier(hooks, path, name) {
  const current = hooks.get(name);
  if (current) {
    return current;
  }
  const newID = addNamed(path, name, "solid-js");
  hooks.set(name, newID);
  return newID;
}

// src/memo-variable.ts
import {
  callExpression as callExpression3,
  identifier,
  memberExpression,
  objectExpression,
  objectProperty as objectProperty2,
  stringLiteral
} from "@babel/types";

// src/accessor-variable.ts
import {
  callExpression as callExpression2
} from "@babel/types";

// src/deref-memo-expression.ts
import {
  blockStatement,
  callExpression,
  isIdentifier as isIdentifier2,
  isObjectProperty as isObjectProperty2,
  objectMethod,
  returnStatement
} from "@babel/types";

// src/errors.ts
function unexpectedType(path, received, expected) {
  return path.buildCodeFrameError(`Unexpected '${received}' (Expected: ${expected})`);
}
function unexpectedMissingParent(path) {
  return path.buildCodeFrameError("Unexpected missing parent.");
}
function unexpectedArgumentLength(path, received, expected) {
  return path.buildCodeFrameError(`Unexpected argument length of ${received} (Expected: ${expected})`);
}
function unexpectedAssignmentOperator(path, received, expected) {
  return path.buildCodeFrameError(`Unexpected assignment operator '${received}' (Expected: ${expected})`);
}

// src/normalize-bindings.ts
import {
  isArrayPattern,
  isArrowFunctionExpression,
  isAssignmentPattern,
  isFunctionDeclaration,
  isFunctionExpression,
  isIdentifier,
  isLabeledStatement,
  isMemberExpression,
  isObjectMethod,
  isObjectProperty,
  isVariableDeclarator,
  objectProperty
} from "@babel/types";
function normalizeBindings(path, replacement, targetIdentifier) {
  return {
    ObjectProperty(p) {
      if (p.scope !== path.scope && p.scope.hasOwnBinding(targetIdentifier.name)) {
        return;
      }
      if (p.node.shorthand && isIdentifier(p.node.key) && p.node.key.name === targetIdentifier.name && isIdentifier(p.node.value) && p.node.value.name === targetIdentifier.name) {
        p.replaceWith(objectProperty(targetIdentifier, replacement));
      }
    },
    Identifier(p) {
      if (p.node.name !== targetIdentifier.name) {
        return;
      }
      if (p.scope !== path.scope && p.scope.hasOwnBinding(targetIdentifier.name)) {
        return;
      }
      if (isObjectMethod(p.parent) && p.parent.key === p.node) {
        return;
      }
      if (isObjectProperty(p.parent) && p.parent.key === p.node) {
        return;
      }
      if (isVariableDeclarator(p.parent)) {
        if (p.parent.id === p.node) {
          return;
        }
      }
      if (isArrayPattern(p.parent) && p.parent.elements.includes(p.node)) {
        return;
      }
      if (isArrowFunctionExpression(p.parent) && p.parent.params.includes(p.node)) {
        return;
      }
      if (isFunctionExpression(p.parent) && p.parent.params.includes(p.node)) {
        return;
      }
      if (isFunctionDeclaration(p.parent) && p.parent.params.includes(p.node)) {
        return;
      }
      if (isLabeledStatement(p.parent) && p.parent.label === p.node) {
        return;
      }
      if (isMemberExpression(p.parent) && p.parent.property === p.node) {
        return;
      }
      if (isFunctionDeclaration(p.parent) && p.parent.id === p.node) {
        return;
      }
      if (isAssignmentPattern(p.parent) && p.parent.left === p.node && (isArrowFunctionExpression(p.parentPath.parent) && p.parentPath.parent.params.includes(p.parent) || isFunctionDeclaration(p.parentPath.parent) && p.parentPath.parent.params.includes(p.parent) || isFunctionExpression(p.parentPath.parent) && p.parentPath.parent.params.includes(p.parent))) {
        return;
      }
      p.replaceWith(replacement);
    }
  };
}

// src/deref-memo-expression.ts
function derefMemoExpression(path, memoIdentifier, readIdentifier) {
  const parent = path.scope.path;
  if (parent) {
    parent.traverse(__spreadValues({
      CallExpression(p) {
        if (p.scope !== path.scope && p.scope.hasOwnBinding(memoIdentifier.name)) {
          return;
        }
        if (!isIdentifier2(p.node.callee)) {
          return;
        }
        switch (p.node.callee.name) {
          case "$refMemo":
            if (!isIdentifier2(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === memoIdentifier.name) {
              p.replaceWith(readIdentifier);
            }
            break;
          case "$get":
            if (!isIdentifier2(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === memoIdentifier.name) {
              p.replaceWith(readIdentifier);
            }
            break;
          case "$getter":
          case "$property":
            if (!p.parentPath) {
              throw unexpectedMissingParent(p);
            }
            if (!isObjectProperty2(p.parent)) {
              throw unexpectedType(p, p.parent.type, "ObjectProperty");
            }
            if (!isIdentifier2(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === memoIdentifier.name) {
              p.parentPath.replaceWith(objectMethod("get", p.parent.key, [], blockStatement([
                returnStatement(callExpression(readIdentifier, []))
              ])));
            }
            break;
          default:
            break;
        }
      }
    }, normalizeBindings(path, callExpression(readIdentifier, []), memoIdentifier)));
  }
}

// src/accessor-variable.ts
function accessorVariableExpression(state, path, accessorIdentifier, mod, replacement) {
  const readIdentifier = path.scope.generateUidIdentifier(accessorIdentifier.name);
  path.node.id = readIdentifier;
  path.node.init = callExpression2(getHookIdentifier(state.hooks, path, mod), replacement);
  derefMemoExpression(path, accessorIdentifier, readIdentifier);
}

// src/normalize-accessor.ts
import {
  arrowFunctionExpression,
  isCallExpression,
  isExpression
} from "@babel/types";
function normalizeAccessor(identifier6) {
  return isCallExpression(identifier6) && identifier6.arguments.length === 0 && isExpression(identifier6.callee) ? identifier6.callee : arrowFunctionExpression([], identifier6);
}

// src/memo-variable.ts
function memoVariableExpression(state, path, memoIdentifier, stateIdentifier, optionsIdentifier) {
  const normalIdentifier = normalizeAccessor(stateIdentifier);
  if (state.opts.dev) {
    if (optionsIdentifier) {
      accessorVariableExpression(state, path, memoIdentifier, "createMemo", [
        normalIdentifier,
        identifier("undefined"),
        callExpression3(memberExpression(identifier("Object"), identifier("assign")), [
          objectExpression([
            objectProperty2(identifier("name"), stringLiteral(memoIdentifier.name))
          ]),
          optionsIdentifier
        ])
      ]);
    } else {
      accessorVariableExpression(state, path, memoIdentifier, "createMemo", [
        normalIdentifier,
        identifier("undefined"),
        objectExpression([
          objectProperty2(identifier("name"), stringLiteral(memoIdentifier.name))
        ])
      ]);
    }
  } else if (optionsIdentifier) {
    accessorVariableExpression(state, path, memoIdentifier, "createMemo", [
      normalIdentifier,
      identifier("undefined"),
      optionsIdentifier
    ]);
  } else {
    accessorVariableExpression(state, path, memoIdentifier, "createMemo", [
      normalIdentifier
    ]);
  }
}

// src/signal-variable.ts
import {
  arrayPattern,
  callExpression as callExpression5,
  identifier as identifier2,
  memberExpression as memberExpression2,
  objectExpression as objectExpression2,
  objectProperty as objectProperty3,
  stringLiteral as stringLiteral2
} from "@babel/types";

// src/deref-signal-expression.ts
import {
  arrayExpression,
  arrowFunctionExpression as arrowFunctionExpression2,
  assignmentExpression,
  binaryExpression,
  blockStatement as blockStatement2,
  callExpression as callExpression4,
  expressionStatement,
  isIdentifier as isIdentifier3,
  isObjectProperty as isObjectProperty3,
  numericLiteral,
  objectMethod as objectMethod2,
  returnStatement as returnStatement2,
  variableDeclaration,
  variableDeclarator
} from "@babel/types";
function derefSignalExpression(path, signalIdentifier, readIdentifier, writeIdentifier) {
  const parent = path.scope.path;
  if (parent) {
    parent.traverse(__spreadProps(__spreadValues({
      CallExpression(p) {
        if (p.scope !== path.scope && p.scope.hasOwnBinding(signalIdentifier.name)) {
          return;
        }
        if (!isIdentifier3(p.node.callee)) {
          return;
        }
        switch (p.node.callee.name) {
          case "$refSignal":
            if (!isIdentifier3(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === signalIdentifier.name) {
              p.replaceWith(arrayExpression([
                readIdentifier,
                writeIdentifier
              ]));
            }
            break;
          case "$get":
            if (!isIdentifier3(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === signalIdentifier.name) {
              p.replaceWith(readIdentifier);
            }
            break;
          case "$set":
            if (!isIdentifier3(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === signalIdentifier.name) {
              p.replaceWith(writeIdentifier);
            }
            break;
          case "$getter":
            if (!p.parentPath) {
              throw unexpectedMissingParent(p);
            }
            if (!isObjectProperty3(p.parent)) {
              throw unexpectedType(p, p.parent.type, "ObjectProperty");
            }
            if (!isIdentifier3(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === signalIdentifier.name) {
              p.parentPath.replaceWith(objectMethod2("get", p.parent.key, [], blockStatement2([
                returnStatement2(callExpression4(readIdentifier, []))
              ])));
            }
            break;
          case "$setter":
            {
              if (!p.parentPath) {
                throw unexpectedMissingParent(p);
              }
              if (!isObjectProperty3(p.parent)) {
                throw unexpectedType(p, p.parent.type, "ObjectProperty");
              }
              if (!isIdentifier3(p.node.arguments[0])) {
                throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
              }
              const param = p.scope.generateUidIdentifier("value");
              if (p.node.arguments[0].name === signalIdentifier.name) {
                p.parentPath.replaceWith(objectMethod2("set", p.parent.key, [param], blockStatement2([
                  returnStatement2(callExpression4(writeIdentifier, [
                    arrowFunctionExpression2([], param)
                  ]))
                ])));
              }
            }
            break;
          case "$property":
            {
              if (!p.parentPath) {
                throw unexpectedMissingParent(p);
              }
              if (!isObjectProperty3(p.parent)) {
                throw unexpectedType(p, p.parent.type, "ObjectProperty");
              }
              if (!isIdentifier3(p.node.arguments[0])) {
                throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
              }
              const param = p.scope.generateUidIdentifier("value");
              if (p.node.arguments[0].name === signalIdentifier.name) {
                p.parentPath.replaceWith(objectMethod2("get", p.parent.key, [], blockStatement2([
                  returnStatement2(callExpression4(readIdentifier, []))
                ])));
                p.parentPath.insertAfter(objectMethod2("set", p.parent.key, [param], blockStatement2([
                  returnStatement2(callExpression4(writeIdentifier, [
                    arrowFunctionExpression2([], param)
                  ]))
                ])));
              }
            }
            break;
          default:
            break;
        }
      }
    }, normalizeBindings(path, callExpression4(readIdentifier, []), signalIdentifier)), {
      UpdateExpression(p) {
        if (p.scope !== path.scope && p.scope.hasOwnBinding(signalIdentifier.name)) {
          return;
        }
        if (isIdentifier3(p.node.argument) && p.node.argument.name === signalIdentifier.name) {
          const param = p.scope.generateUidIdentifier("current");
          if (p.node.prefix) {
            p.replaceWith(callExpression4(writeIdentifier, [
              arrowFunctionExpression2([param], binaryExpression(p.node.operator === "++" ? "+" : "-", param, numericLiteral(1)))
            ]));
          } else {
            p.replaceWith(callExpression4(arrowFunctionExpression2([], blockStatement2([
              variableDeclaration("const", [
                variableDeclarator(param, callExpression4(readIdentifier, []))
              ]),
              expressionStatement(callExpression4(writeIdentifier, [
                arrowFunctionExpression2([], binaryExpression(p.node.operator === "++" ? "+" : "-", param, numericLiteral(1)))
              ])),
              returnStatement2(param)
            ])), []));
          }
        }
      },
      AssignmentExpression(p) {
        if (p.scope !== path.scope && p.scope.hasOwnBinding(signalIdentifier.name)) {
          return;
        }
        const identifier6 = p.node.left;
        const expression = p.node.right;
        if (isIdentifier3(identifier6) && identifier6.name === signalIdentifier.name) {
          if (p.node.operator === "=") {
            p.replaceWith(callExpression4(writeIdentifier, [
              arrowFunctionExpression2([], expression)
            ]));
          } else {
            const param = p.scope.generateUidIdentifier("current");
            p.replaceWith(callExpression4(writeIdentifier, [
              arrowFunctionExpression2([param], assignmentExpression(p.node.operator, param, expression))
            ]));
          }
        }
      }
    }));
  }
}

// src/signal-variable.ts
function signalVariableExpression(state, path, signalIdentifier, stateIdentifier = identifier2("undefined"), optionsIdentifier) {
  const readIdentifier = path.scope.generateUidIdentifier(signalIdentifier.name);
  const writeIdentifier = path.scope.generateUidIdentifier(`set${signalIdentifier.name}`);
  path.node.id = arrayPattern([
    readIdentifier,
    writeIdentifier
  ]);
  if (state.opts.dev) {
    if (optionsIdentifier) {
      path.node.init = callExpression5(getHookIdentifier(state.hooks, path, "createSignal"), [
        stateIdentifier,
        callExpression5(memberExpression2(identifier2("Object"), identifier2("assign")), [
          objectExpression2([
            objectProperty3(identifier2("name"), stringLiteral2(signalIdentifier.name))
          ]),
          optionsIdentifier
        ])
      ]);
    } else {
      path.node.init = callExpression5(getHookIdentifier(state.hooks, path, "createSignal"), [
        stateIdentifier,
        objectExpression2([
          objectProperty3(identifier2("name"), stringLiteral2(signalIdentifier.name))
        ])
      ]);
    }
  } else if (optionsIdentifier) {
    path.node.init = callExpression5(getHookIdentifier(state.hooks, path, "createSignal"), [
      stateIdentifier,
      optionsIdentifier
    ]);
  } else {
    path.node.init = callExpression5(getHookIdentifier(state.hooks, path, "createSignal"), [
      stateIdentifier
    ]);
  }
  derefSignalExpression(path, signalIdentifier, readIdentifier, writeIdentifier);
}

// src/deferred-variable.ts
import {
  callExpression as callExpression6,
  identifier as identifier3,
  memberExpression as memberExpression3,
  objectExpression as objectExpression3,
  objectProperty as objectProperty4,
  stringLiteral as stringLiteral3
} from "@babel/types";
function deferredVariableExpression(state, path, deferredIdentifier, stateIdentifier = identifier3("undefined"), optionsIdentifier) {
  const normalIdentifier = normalizeAccessor(stateIdentifier);
  if (state.opts.dev) {
    if (optionsIdentifier) {
      accessorVariableExpression(state, path, deferredIdentifier, "createDeferred", [
        normalIdentifier,
        callExpression6(memberExpression3(identifier3("Object"), identifier3("assign")), [
          objectExpression3([
            objectProperty4(identifier3("name"), stringLiteral3(deferredIdentifier.name))
          ]),
          optionsIdentifier
        ])
      ]);
    } else {
      accessorVariableExpression(state, path, deferredIdentifier, "createDeferred", [
        normalIdentifier,
        objectExpression3([
          objectProperty4(identifier3("name"), stringLiteral3(deferredIdentifier.name))
        ])
      ]);
    }
  } else if (optionsIdentifier) {
    accessorVariableExpression(state, path, deferredIdentifier, "createDeferred", [
      normalIdentifier,
      optionsIdentifier
    ]);
  } else {
    accessorVariableExpression(state, path, deferredIdentifier, "createDeferred", [
      normalIdentifier
    ]);
  }
}

// src/destructure-variable.ts
import {
  arrayExpression as arrayExpression2,
  arrowFunctionExpression as arrowFunctionExpression3,
  callExpression as callExpression7,
  isArrayPattern as isArrayPattern2,
  isAssignmentPattern as isAssignmentPattern2,
  isIdentifier as isIdentifier4,
  isObjectPattern,
  isObjectProperty as isObjectProperty4,
  isRestElement,
  memberExpression as memberExpression4,
  numericLiteral as numericLiteral2,
  stringLiteral as stringLiteral4,
  variableDeclarator as variableDeclarator2
} from "@babel/types";
function destructureVariableExpression(state, path, target, pattern, replace = true) {
  const otherIdentifier = path.scope.generateUidIdentifier("other");
  const properties = [];
  let restIdentifier;
  if (isObjectPattern(pattern)) {
    for (let i = 0, len = pattern.properties.length; i < len; i += 1) {
      const property = pattern.properties[i];
      if (isObjectProperty4(property)) {
        const { value, key } = property;
        if (!property.computed) {
          if (isIdentifier4(key)) {
            properties.push(stringLiteral4(key.name));
          }
        } else {
          properties.push(key);
        }
        const newIdentifier = path.scope.generateUidIdentifier("prop");
        path.insertBefore(variableDeclarator2(newIdentifier, arrowFunctionExpression3([], memberExpression4(target, key, property.computed))));
        if (isObjectPattern(value) || isArrayPattern2(value)) {
          destructureVariableExpression(state, path, callExpression7(newIdentifier, []), value, false);
        } else if (isIdentifier4(value)) {
          path.scope.path.traverse(normalizeBindings(path.scope.path, callExpression7(newIdentifier, []), value));
        } else if (isAssignmentPattern2(value)) {
        } else {
          throw unexpectedType(path, value.type, "Identifier | ObjectPattern | ArrayPattern");
        }
      } else if (isIdentifier4(property.argument)) {
        restIdentifier = property.argument;
      }
    }
  } else {
    for (let i = 0, len = pattern.elements.length; i < len; i += 1) {
      const property = pattern.elements[i];
      if (property) {
        const keyExpr = numericLiteral2(i);
        const newIdentifier = path.scope.generateUidIdentifier("prop");
        path.insertBefore(variableDeclarator2(newIdentifier, arrowFunctionExpression3([], memberExpression4(target, keyExpr, true))));
        properties.push(keyExpr);
        if (isIdentifier4(property)) {
          path.scope.path.traverse(normalizeBindings(path.scope.path, callExpression7(newIdentifier, []), property));
        } else if (isArrayPattern2(property) || isObjectPattern(property)) {
          destructureVariableExpression(state, path, callExpression7(newIdentifier, []), property, false);
        } else if (isRestElement(property)) {
          if (isIdentifier4(property.argument)) {
            restIdentifier = property.argument;
          }
        } else {
        }
      }
    }
  }
  const expr = variableDeclarator2(otherIdentifier, properties.length ? memberExpression4(callExpression7(getHookIdentifier(state.hooks, path, "splitProps"), [target, arrayExpression2(properties)]), numericLiteral2(1), true) : target);
  if (replace) {
    path.replaceWith(expr);
  } else {
    path.insertAfter(expr);
  }
  if (restIdentifier) {
    path.scope.path.traverse(normalizeBindings(path.scope.path, otherIdentifier, restIdentifier));
  }
}

// src/label-parser.ts
function createVariableLabel(variableExpression) {
  return (state, path) => {
    const { body } = path.node;
    if (isExpressionStatement(body)) {
      if (isAssignmentExpression(body.expression)) {
        if (body.expression.operator !== "=") {
          throw unexpectedAssignmentOperator(path, body.expression.operator, "=");
        }
        const leftExpr = body.expression.left;
        const rightExpr = body.expression.right;
        if (!isIdentifier5(leftExpr)) {
          throw unexpectedType(path, leftExpr.type, "Identifier");
        }
        path.replaceWith(variableDeclaration2("const", [
          variableDeclarator3(leftExpr, rightExpr)
        ]));
      } else if (isIdentifier5(body.expression)) {
        path.replaceWith(variableDeclaration2("const", [
          variableDeclarator3(body.expression)
        ]));
      } else if (isSequenceExpression(body.expression)) {
        const exprs = [];
        for (let i = 0, len = body.expression.expressions.length; i < len; i += 1) {
          const expr = body.expression.expressions[i];
          if (isIdentifier5(expr)) {
            exprs.push(variableDeclarator3(expr));
          } else if (isAssignmentExpression(expr)) {
            if (expr.operator !== "=") {
              throw new Error("Invalid assignment expression operator");
            }
            const leftExpr = expr.left;
            const rightExpr = expr.right;
            if (!isIdentifier5(leftExpr)) {
              throw unexpectedType(path, leftExpr.type, "Identifier");
            }
            path.replaceWith(variableDeclarator3(leftExpr, rightExpr));
          } else {
            throw unexpectedType(path, expr.type, "Identifier | AssignmentExpression");
          }
        }
        path.replaceWith(variableDeclaration2("const", exprs));
      }
    }
    if (isVariableDeclaration(body)) {
      body.kind = "const";
      path.replaceWith(body);
    }
    if (isVariableDeclaration(path.node)) {
      path.traverse({
        VariableDeclarator(p) {
          const leftExpr = p.node.id;
          const rightExpr = p.node.init;
          variableExpression(state, p, leftExpr, rightExpr);
        }
      });
    } else {
      throw unexpectedType(path, path.node.type, "VariableDeclaration");
    }
  };
}
function reactiveExpression(state, path) {
  const { body } = path.node;
  if (isExpressionStatement(body)) {
    path.replaceWith(callExpression8(getHookIdentifier(state.hooks, path, "createEffect"), [
      arrowFunctionExpression4([], body.expression)
    ]));
  } else if (isBlockStatement(body)) {
    path.replaceWith(callExpression8(getHookIdentifier(state.hooks, path, "createEffect"), [
      arrowFunctionExpression4([], body)
    ]));
  } else if (isVariableDeclaration(body)) {
    body.kind = "const";
    path.replaceWith(body);
    path.traverse({
      VariableDeclarator(p) {
        const leftExpr = p.node.id;
        const rightExpr = p.node.init;
        if (isIdentifier5(leftExpr)) {
          memoVariableExpression(state, p, leftExpr, rightExpr != null ? rightExpr : identifier4("undefined"));
        }
      }
    });
  }
}
function createCallbackLabel(label, named = false) {
  return function expr(state, path) {
    let { body } = path.node;
    let name;
    let callback;
    if (named && isLabeledStatement2(body)) {
      name = body.label.name;
      body = body.body;
    }
    if (isBlockStatement(body)) {
      callback = arrowFunctionExpression4([], body);
    } else if (isExpressionStatement(body)) {
      callback = body.expression;
    } else {
      throw unexpectedType(path, body.type, "BlockStatement | ExpressionStatement");
    }
    if (name) {
      path.replaceWith(callExpression8(getHookIdentifier(state.hooks, path, label), [
        callback,
        identifier4("undefined"),
        objectExpression4([
          objectProperty5(identifier4("name"), stringLiteral5(name))
        ])
      ]));
    } else {
      path.replaceWith(callExpression8(getHookIdentifier(state.hooks, path, label), [
        callback
      ]));
    }
  };
}
var EXPRESSIONS = {
  $: reactiveExpression,
  signal: createVariableLabel((state, path, leftExpr, rightExpr) => {
    if (isIdentifier5(leftExpr)) {
      signalVariableExpression(state, path, leftExpr, rightExpr != null ? rightExpr : identifier4("undefined"));
    }
  }),
  memo: createVariableLabel((state, path, leftExpr, rightExpr) => {
    if (isIdentifier5(leftExpr)) {
      memoVariableExpression(state, path, leftExpr, rightExpr != null ? rightExpr : identifier4("undefined"));
    }
  }),
  deferred: createVariableLabel((state, path, leftExpr, rightExpr) => {
    if (isIdentifier5(leftExpr)) {
      deferredVariableExpression(state, path, leftExpr, rightExpr != null ? rightExpr : identifier4("undefined"));
    }
  }),
  destructure: createVariableLabel((state, path, leftExpr, rightExpr) => {
    if ((isObjectPattern2(leftExpr) || isArrayPattern3(leftExpr)) && rightExpr) {
      destructureVariableExpression(state, path, rightExpr, leftExpr);
    }
  }),
  children: createVariableLabel((state, path, leftExpr, rightExpr) => {
    if (isIdentifier5(leftExpr)) {
      accessorVariableExpression(state, path, leftExpr, "children", [
        arrowFunctionExpression4([], rightExpr != null ? rightExpr : identifier4("undefined"))
      ]);
    }
  }),
  effect: createCallbackLabel("createEffect", true),
  computed: createCallbackLabel("createComputed", true),
  renderEffect: createCallbackLabel("createRenderEffect", true),
  mount: createCallbackLabel("onMount"),
  cleanup: createCallbackLabel("onCleanup"),
  error: createCallbackLabel("onError"),
  root: createCallbackLabel("createRoot"),
  untrack: createCallbackLabel("untrack"),
  batch: createCallbackLabel("batch"),
  transition: createCallbackLabel("startTransition")
};
var LABEL_PARSER = {
  LabeledStatement(path, state) {
    if (path.node.label.name in EXPRESSIONS) {
      EXPRESSIONS[path.node.label.name](state, path);
    }
  }
};
var label_parser_default = LABEL_PARSER;

// src/comment-parser.ts
import {
  arrowFunctionExpression as arrowFunctionExpression5,
  callExpression as callExpression9,
  identifier as identifier5,
  isArrayPattern as isArrayPattern4,
  isBlockStatement as isBlockStatement2,
  isFunctionDeclaration as isFunctionDeclaration2,
  isIdentifier as isIdentifier6,
  isObjectPattern as isObjectPattern3,
  objectExpression as objectExpression5,
  objectProperty as objectProperty6,
  stringLiteral as stringLiteral6
} from "@babel/types";
function signalExpression(state, path) {
  path.traverse({
    VariableDeclarator(p) {
      const leftExpr = p.node.id;
      const rightExpr = p.node.init;
      if (isIdentifier6(leftExpr)) {
        signalVariableExpression(state, p, leftExpr, rightExpr != null ? rightExpr : void 0);
      }
    }
  });
}
function memoExpression(state, path) {
  path.traverse({
    VariableDeclarator(p) {
      const leftExpr = p.node.id;
      const rightExpr = p.node.init;
      if (isIdentifier6(leftExpr)) {
        memoVariableExpression(state, p, leftExpr, rightExpr != null ? rightExpr : identifier5("undefined"));
      }
    }
  });
}
function destructureExpression(state, path) {
  path.traverse({
    VariableDeclarator(p) {
      const leftExpr = p.node.id;
      const rightExpr = p.node.init;
      if ((isObjectPattern3(leftExpr) || isArrayPattern4(leftExpr)) && rightExpr) {
        destructureVariableExpression(state, p, rightExpr, leftExpr);
      }
    }
  });
}
function deferredExpression(state, path) {
  path.traverse({
    VariableDeclarator(p) {
      const leftExpr = p.node.id;
      const rightExpr = p.node.init;
      if (isIdentifier6(leftExpr)) {
        deferredVariableExpression(state, p, leftExpr, rightExpr != null ? rightExpr : identifier5("undefined"));
      }
    }
  });
}
function childrenExpression(state, path) {
  path.traverse({
    VariableDeclarator(p) {
      const leftExpr = p.node.id;
      const rightExpr = p.node.init;
      if (isIdentifier6(leftExpr)) {
        accessorVariableExpression(state, p, leftExpr, "children", [
          arrowFunctionExpression5([], rightExpr != null ? rightExpr : identifier5("undefined"))
        ]);
      }
    }
  });
}
function createCallbackLabel2(label, named = false) {
  return function expr(state, path, name) {
    const body = path.node;
    let callback;
    if (isBlockStatement2(body)) {
      callback = arrowFunctionExpression5([], body);
    } else {
      callback = body.expression;
    }
    if (named && name) {
      path.replaceWith(callExpression9(getHookIdentifier(state.hooks, path, label), [
        callback,
        identifier5("undefined"),
        objectExpression5([
          objectProperty6(identifier5("name"), stringLiteral6(name))
        ])
      ]));
    } else {
      path.replaceWith(callExpression9(getHookIdentifier(state.hooks, path, label), [
        callback
      ]));
    }
  };
}
var STATE_EXPRESSIONS = {
  "@signal": signalExpression,
  "@memo": memoExpression,
  "@children": childrenExpression,
  "@deferred": deferredExpression,
  "@destructure": destructureExpression
};
var CALLBACK_EXPRESSIONS = {
  "@effect": createCallbackLabel2("createEffect", true),
  "@computed": createCallbackLabel2("createComputed", true),
  "@renderEffect": createCallbackLabel2("createRenderEffect", true),
  "@mount": createCallbackLabel2("onMount"),
  "@cleanup": createCallbackLabel2("onCleanup"),
  "@error": createCallbackLabel2("onError"),
  "@root": createCallbackLabel2("createRoot"),
  "@untrack": createCallbackLabel2("untrack"),
  "@batch": createCallbackLabel2("batch"),
  "@transition": createCallbackLabel2("startTransition")
};
var COMMENT_PARSER = {
  VariableDeclaration(path, state) {
    const comments = path.node.leadingComments;
    if (comments) {
      let preference;
      for (let i = 0, len = comments.length; i < len; i += 1) {
        const comment = comments[i];
        const value = comment.value.trim();
        if (value in STATE_EXPRESSIONS) {
          preference = value;
          comment.value = "";
        }
      }
      if (preference) {
        STATE_EXPRESSIONS[preference](state, path);
      }
    }
  },
  BlockStatement(path, state) {
    if (isFunctionDeclaration2(path.parent)) {
      return;
    }
    const comments = path.node.leadingComments;
    if (comments) {
      let preference;
      let name;
      for (let i = 0, len = comments.length; i < len; i += 1) {
        const comment = comments[i];
        const value = comment.value.trim();
        if (/^@\w+( .*)?$/.test(value)) {
          const [tag, ...debugName] = value.split(" ");
          if (tag in CALLBACK_EXPRESSIONS) {
            preference = tag;
            name = debugName.join(" ");
            comment.value = "";
          }
        }
      }
      if (preference) {
        CALLBACK_EXPRESSIONS[preference](state, path, name);
      }
    }
  },
  ExpressionStatement(path, state) {
    const comments = path.node.leadingComments;
    if (comments) {
      let preference;
      let name;
      for (let i = 0, len = comments.length; i < len; i += 1) {
        const comment = comments[i];
        const value = comment.value.trim();
        if (/^@\w+( .*)?$/.test(value)) {
          const [tag, ...debugName] = value.split(" ");
          if (tag in CALLBACK_EXPRESSIONS) {
            preference = tag;
            name = debugName.join(" ");
            comment.value = "";
          }
        }
      }
      if (preference) {
        CALLBACK_EXPRESSIONS[preference](state, path, name);
      }
    }
  }
};
var comment_parser_default = COMMENT_PARSER;

// src/ctf-parser.ts
import {
  arrowFunctionExpression as arrowFunctionExpression6,
  callExpression as callExpression10,
  isArrayPattern as isArrayPattern5,
  isArrowFunctionExpression as isArrowFunctionExpression2,
  isExpression as isExpression2,
  isExpressionStatement as isExpressionStatement2,
  isFunctionExpression as isFunctionExpression2,
  isIdentifier as isIdentifier7,
  isObjectPattern as isObjectPattern4,
  isVariableDeclarator as isVariableDeclarator2
} from "@babel/types";

// src/deref-signal-variable.ts
import {
  arrayPattern as arrayPattern2
} from "@babel/types";
function derefSignalVariableExpression(path, signalIdentifier, stateIdentifier) {
  const readIdentifier = path.scope.generateUidIdentifier(signalIdentifier.name);
  const writeIdentifier = path.scope.generateUidIdentifier(`set${signalIdentifier.name}`);
  path.node.id = arrayPattern2([
    readIdentifier,
    writeIdentifier
  ]);
  path.node.init = stateIdentifier;
  derefSignalExpression(path, signalIdentifier, readIdentifier, writeIdentifier);
}

// src/deref-memo-variable.ts
function derefMemoVariableExpression(path, memoIdentifier, stateIdentifier) {
  const readIdentifier = path.scope.generateUidIdentifier(memoIdentifier.name);
  path.node.id = readIdentifier;
  path.node.init = stateIdentifier;
  derefMemoExpression(path, memoIdentifier, readIdentifier);
}

// src/ctf-parser.ts
function derefSignalExpression2(_, path) {
  if (path.node.arguments.length > 1) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);
  }
  const argument = path.node.arguments[0];
  if (!isExpression2(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!isVariableDeclarator2(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!isIdentifier7(leftExpr)) {
    throw unexpectedType(path.parentPath, leftExpr.type, "Identifier");
  }
  derefSignalVariableExpression(path.parentPath, leftExpr, argument);
}
function signalExpression2(state, path) {
  if (path.node.arguments.length > 2) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 2);
  }
  let argument;
  let options;
  if (path.node.arguments.length > 0) {
    const initialState = path.node.arguments[0];
    if (!isExpression2(initialState)) {
      throw unexpectedType(path, initialState.type, "Expression");
    }
    argument = initialState;
    if (path.node.arguments.length > 1) {
      const optionsValue = path.node.arguments[1];
      if (!isExpression2(optionsValue)) {
        throw unexpectedType(path, optionsValue.type, "Expression");
      }
      options = optionsValue;
    }
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!isVariableDeclarator2(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!isIdentifier7(leftExpr)) {
    throw unexpectedType(path.parentPath, leftExpr.type, "Identifier");
  }
  signalVariableExpression(state, path.parentPath, leftExpr, argument, options);
}
function derefMemoExpression2(_, path) {
  if (path.node.arguments.length > 1) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);
  }
  const argument = path.node.arguments[0];
  if (!isExpression2(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!isVariableDeclarator2(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!isIdentifier7(leftExpr)) {
    throw unexpectedType(path.parentPath, leftExpr.type, "Expression");
  }
  derefMemoVariableExpression(path.parentPath, leftExpr, argument);
}
function memoExpression2(state, path) {
  if (path.node.arguments.length > 2) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 2);
  }
  const argument = path.node.arguments[0];
  if (!isExpression2(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  let options;
  if (path.node.arguments.length > 1) {
    const optionsValue = path.node.arguments[1];
    if (!isExpression2(optionsValue)) {
      throw unexpectedType(path, optionsValue.type, "Expression");
    }
    options = optionsValue;
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!isVariableDeclarator2(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!isIdentifier7(leftExpr)) {
    throw unexpectedType(path.parentPath, leftExpr.type, "Expression");
  }
  memoVariableExpression(state, path.parentPath, leftExpr, argument, options);
}
function deferredExpression2(state, path) {
  if (path.node.arguments.length > 2) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 2);
  }
  let argument;
  let options;
  if (path.node.arguments.length > 0) {
    const initialState = path.node.arguments[0];
    if (!isExpression2(initialState)) {
      throw unexpectedType(path, initialState.type, "Expression");
    }
    argument = initialState;
    if (path.node.arguments.length > 1) {
      const optionsValue = path.node.arguments[1];
      if (!isExpression2(optionsValue)) {
        throw unexpectedType(path, optionsValue.type, "Expression");
      }
      options = optionsValue;
    }
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!isVariableDeclarator2(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!isIdentifier7(leftExpr)) {
    throw unexpectedType(path, leftExpr.type, "Identifier");
  }
  deferredVariableExpression(state, path.parentPath, leftExpr, argument, options);
}
function reactiveExpression2(state, path) {
  if (path.node.arguments.length > 1) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);
  }
  const argument = path.node.arguments[0];
  if (!isExpression2(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (isVariableDeclarator2(path.parent)) {
    const leftExpr = path.parent.id;
    if (!isIdentifier7(leftExpr)) {
      throw unexpectedType(path, leftExpr.type, "Identifier");
    }
    memoVariableExpression(state, path.parentPath, leftExpr, argument);
  } else if (isExpressionStatement2(path.parent)) {
    path.replaceWith(callExpression10(getHookIdentifier(state.hooks, path, "createEffect"), [
      arrowFunctionExpression6([], argument)
    ]));
  } else {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator | ExpressionStatement");
  }
}
function rootExpression(state, path) {
  if (path.node.arguments.length > 1) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);
  }
  const argument = path.node.arguments[0];
  if (!isExpression2(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  const arrow = isArrowFunctionExpression2(argument) || isFunctionExpression2(argument) ? argument : arrowFunctionExpression6([], argument);
  path.replaceWith(callExpression10(getHookIdentifier(state.hooks, path, "createRoot"), [
    arrow
  ]));
}
function fromExpression(state, path) {
  if (path.node.arguments.length > 1) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);
  }
  const argument = path.node.arguments[0];
  if (!isExpression2(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!isVariableDeclarator2(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!isIdentifier7(leftExpr)) {
    throw unexpectedType(path, leftExpr.type, "Identifier");
  }
  accessorVariableExpression(state, path.parentPath, leftExpr, "from", [
    argument
  ]);
}
function createCompileTimeAutoAccessor(target, limit) {
  return (state, path) => {
    if (path.node.arguments.length > limit) {
      throw unexpectedArgumentLength(path, path.node.arguments.length, limit);
    }
    const [argument, ...rest] = path.node.arguments;
    if (!isExpression2(argument)) {
      throw unexpectedType(path, argument.type, "Expression");
    }
    if (!path.parentPath) {
      throw unexpectedMissingParent(path);
    }
    if (!isVariableDeclarator2(path.parent)) {
      throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
    }
    const leftExpr = path.parent.id;
    if (!isIdentifier7(leftExpr)) {
      throw unexpectedType(path, leftExpr.type, "Identifier");
    }
    accessorVariableExpression(state, path.parentPath, leftExpr, target, [
      normalizeAccessor(argument),
      ...rest
    ]);
  };
}
function createCompileTimeAlias(target) {
  return (state, path) => {
    path.node.callee = getHookIdentifier(state.hooks, path, target);
  };
}
function createCompileTimeAutoArrow(target, limit) {
  return (state, path) => {
    if (path.node.arguments.length > limit) {
      throw unexpectedArgumentLength(path, path.node.arguments.length, limit);
    }
    const [argument, ...rest] = path.node.arguments;
    if (!isExpression2(argument)) {
      throw unexpectedType(path, argument.type, "Expression");
    }
    path.replaceWith(callExpression10(getHookIdentifier(state.hooks, path, target), [
      normalizeAccessor(argument),
      ...rest
    ]));
  };
}
function destructureExpression2(state, path) {
  if (path.node.arguments.length > 1) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);
  }
  const argument = path.node.arguments[0];
  if (!isExpression2(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!isVariableDeclarator2(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!(isObjectPattern4(leftExpr) || isArrayPattern5(leftExpr))) {
    throw unexpectedType(path, leftExpr.type, "ArrayPattern | ObjectPattern");
  }
  destructureVariableExpression(state, path.parentPath, argument, leftExpr);
}
var CTF_EXPRESSIONS = {
  $: reactiveExpression2,
  $derefSignal: derefSignalExpression2,
  $derefMemo: derefMemoExpression2,
  $signal: signalExpression2,
  $memo: memoExpression2,
  $root: rootExpression,
  $from: fromExpression,
  $deferred: deferredExpression2,
  $children: createCompileTimeAutoAccessor("children", 1),
  $mapArray: createCompileTimeAutoAccessor("mapArray", 3),
  $indexArray: createCompileTimeAutoAccessor("indexArray", 3),
  $lazy: createCompileTimeAutoArrow("lazy", 1),
  $untrack: createCompileTimeAutoArrow("untrack", 1),
  $batch: createCompileTimeAutoArrow("batch", 1),
  $observable: createCompileTimeAutoArrow("observable", 1),
  $selector: createCompileTimeAutoArrow("createSelector", 1),
  $on: createCompileTimeAutoArrow("on", 3),
  $useContext: createCompileTimeAlias("useContext"),
  $createContext: createCompileTimeAlias("createContext"),
  $uid: createCompileTimeAlias("createUniqueId"),
  $effect: createCompileTimeAlias("createEffect"),
  $computed: createCompileTimeAlias("createComputed"),
  $renderEffect: createCompileTimeAlias("createRenderEffect"),
  $merge: createCompileTimeAlias("mergeProps"),
  $destructure: destructureExpression2
};
var CTF_PARSER = {
  CallExpression(path, state) {
    if (isIdentifier7(path.node.callee) && path.node.callee.name in CTF_EXPRESSIONS) {
      CTF_EXPRESSIONS[path.node.callee.name](state, path);
    }
  }
};
var ctf_parser_default = CTF_PARSER;

// src/index.ts
function solidReactivityPlugin() {
  return {
    pre() {
      this.hooks = new Map();
    },
    visitor: __spreadValues(__spreadValues(__spreadValues({}, label_parser_default), comment_parser_default), ctf_parser_default)
  };
}
export {
  solidReactivityPlugin as default
};
//# sourceMappingURL=index.mjs.map

{
  "version": 3,
  "sources": ["../../src/label-parser.ts", "../../src/get-hook-identifier.ts", "../../src/memo-variable.ts", "../../src/accessor-variable.ts", "../../src/deref-memo-expression.ts", "../../src/errors.ts", "../../src/normalize-bindings.ts", "../../src/normalize-accessor.ts", "../../src/signal-variable.ts", "../../src/deref-signal-expression.ts", "../../src/deferred-variable.ts", "../../src/destructure-variable.ts", "../../src/comment-parser.ts", "../../src/ctf-parser.ts", "../../src/deref-signal-variable.ts", "../../src/deref-memo-variable.ts", "../../src/index.ts"],
  "sourcesContent": ["import { NodePath, Visitor } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport getHookIdentifier from './get-hook-identifier';\nimport memoVariableExpression from './memo-variable';\nimport signalVariableExpression from './signal-variable';\nimport accessorVariableExpression from './accessor-variable';\nimport { State } from './types';\nimport deferredVariableExpression from './deferred-variable';\nimport destructureVariableExpression from './destructure-variable';\nimport { unexpectedAssignmentOperator, unexpectedType } from './errors';\n\ntype VariableLabelExpression = (\n  state: State,\n  path: NodePath<t.VariableDeclarator>,\n  leftExpr: t.LVal,\n  rightExpr: t.Expression | null | undefined,\n) => void;\n\nfunction createVariableLabel(variableExpression: VariableLabelExpression) {\n  return (\n    state: State,\n    path: NodePath<t.LabeledStatement>,\n  ) => {\n    const { body } = path.node;\n    if (t.isExpressionStatement(body)) {\n      if (t.isAssignmentExpression(body.expression)) {\n        if (body.expression.operator !== '=') {\n          throw unexpectedAssignmentOperator(path, body.expression.operator, '=');\n        }\n        const leftExpr = body.expression.left;\n        const rightExpr = body.expression.right;\n        if (!t.isIdentifier(leftExpr)) {\n          throw unexpectedType(path, leftExpr.type, 'Identifier');\n        }\n        path.replaceWith(\n          t.variableDeclaration(\n            'const',\n            [\n              t.variableDeclarator(\n                leftExpr,\n                rightExpr,\n              ),\n            ],\n          ),\n        );\n      } else if (t.isIdentifier(body.expression)) {\n        path.replaceWith(\n          t.variableDeclaration(\n            'const',\n            [\n              t.variableDeclarator(\n                body.expression,\n              ),\n            ],\n          ),\n        );\n      } else if (t.isSequenceExpression(body.expression)) {\n        const exprs: t.VariableDeclarator[] = [];\n        for (let i = 0, len = body.expression.expressions.length; i < len; i += 1) {\n          const expr = body.expression.expressions[i];\n\n          if (t.isIdentifier(expr)) {\n            exprs.push(\n              t.variableDeclarator(\n                expr,\n              ),\n            );\n          } else if (t.isAssignmentExpression(expr)) {\n            if (expr.operator !== '=') {\n              throw new Error('Invalid assignment expression operator');\n            }\n            const leftExpr = expr.left;\n            const rightExpr = expr.right;\n            if (!t.isIdentifier(leftExpr)) {\n              throw unexpectedType(path, leftExpr.type, 'Identifier');\n            }\n            path.replaceWith(\n              t.variableDeclarator(\n                leftExpr,\n                rightExpr,\n              ),\n            );\n          } else {\n            throw unexpectedType(path, expr.type, 'Identifier | AssignmentExpression');\n          }\n        }\n\n        path.replaceWith(\n          t.variableDeclaration(\n            'const',\n            exprs,\n          ),\n        );\n      }\n    }\n    if (t.isVariableDeclaration(body)) {\n      body.kind = 'const';\n      path.replaceWith(\n        body,\n      );\n    }\n    if (t.isVariableDeclaration(path.node)) {\n      path.traverse({\n        VariableDeclarator(p) {\n          const leftExpr = p.node.id;\n          const rightExpr = p.node.init;\n          variableExpression(state, p, leftExpr, rightExpr);\n        },\n      });\n    } else {\n      throw unexpectedType(path, path.node.type, 'VariableDeclaration');\n    }\n  };\n}\n\nfunction reactiveExpression(\n  state: State,\n  path: NodePath<t.LabeledStatement>,\n): void {\n  const { body } = path.node;\n  if (t.isExpressionStatement(body)) {\n    path.replaceWith(\n      t.callExpression(\n        getHookIdentifier(state.hooks, path, 'createEffect'),\n        [\n          t.arrowFunctionExpression(\n            [],\n            body.expression,\n          ),\n        ],\n      ),\n    );\n  } else if (t.isBlockStatement(body)) {\n    path.replaceWith(\n      t.callExpression(\n        getHookIdentifier(state.hooks, path, 'createEffect'),\n        [\n          t.arrowFunctionExpression(\n            [],\n            body,\n          ),\n        ],\n      ),\n    );\n  } else if (t.isVariableDeclaration(body)) {\n    body.kind = 'const';\n    path.replaceWith(body);\n    path.traverse({\n      VariableDeclarator(p) {\n        const leftExpr = p.node.id;\n        const rightExpr = p.node.init;\n        if (t.isIdentifier(leftExpr)) {\n          memoVariableExpression(state, p, leftExpr, rightExpr ?? t.identifier('undefined'));\n        }\n      },\n    });\n  }\n}\n\nfunction createCallbackLabel(label: string, named = false) {\n  return function expr(\n    state: State,\n    path: NodePath<t.LabeledStatement>,\n  ): void {\n    let { body } = path.node;\n    let name: string | undefined;\n    let callback: t.Expression;\n    if (named && t.isLabeledStatement(body)) {\n      name = body.label.name;\n      body = body.body;\n    }\n    if (t.isBlockStatement(body)) {\n      callback = t.arrowFunctionExpression(\n        [],\n        body,\n      );\n    } else if (t.isExpressionStatement(body)) {\n      callback = body.expression;\n    } else {\n      throw unexpectedType(path, body.type, 'BlockStatement | ExpressionStatement');\n    }\n    if (name) {\n      path.replaceWith(\n        t.callExpression(\n          getHookIdentifier(state.hooks, path, label),\n          [\n            callback,\n            t.identifier('undefined'),\n            t.objectExpression([\n              t.objectProperty(\n                t.identifier('name'),\n                t.stringLiteral(name),\n              ),\n            ]),\n          ],\n        ),\n      );\n    } else {\n      path.replaceWith(\n        t.callExpression(\n          getHookIdentifier(state.hooks, path, label),\n          [\n            callback,\n          ],\n        ),\n      );\n    }\n  };\n}\n\ntype LabelExpression = (\n  state: State,\n  path: NodePath<t.LabeledStatement>,\n) => void;\n\nconst EXPRESSIONS: Record<string, LabelExpression> = {\n  $: reactiveExpression,\n  signal: createVariableLabel((state, path, leftExpr, rightExpr) => {\n    if (t.isIdentifier(leftExpr)) {\n      signalVariableExpression(state, path, leftExpr, rightExpr ?? t.identifier('undefined'));\n    }\n  }),\n  memo: createVariableLabel((state, path, leftExpr, rightExpr) => {\n    if (t.isIdentifier(leftExpr)) {\n      memoVariableExpression(state, path, leftExpr, rightExpr ?? t.identifier('undefined'));\n    }\n  }),\n  deferred: createVariableLabel((state, path, leftExpr, rightExpr) => {\n    if (t.isIdentifier(leftExpr)) {\n      deferredVariableExpression(state, path, leftExpr, rightExpr ?? t.identifier('undefined'));\n    }\n  }),\n  destructure: createVariableLabel((state, path, leftExpr, rightExpr) => {\n    if ((t.isObjectPattern(leftExpr) || t.isArrayPattern(leftExpr)) && rightExpr) {\n      destructureVariableExpression(\n        state,\n        path,\n        rightExpr,\n        leftExpr,\n      );\n    }\n  }),\n  children: createVariableLabel((state, path, leftExpr, rightExpr) => {\n    if (t.isIdentifier(leftExpr)) {\n      accessorVariableExpression(\n        state,\n        path,\n        leftExpr,\n        'children',\n        [\n          t.arrowFunctionExpression(\n            [],\n            rightExpr ?? t.identifier('undefined'),\n          ),\n        ],\n      );\n    }\n  }),\n  effect: createCallbackLabel('createEffect', true),\n  computed: createCallbackLabel('createComputed', true),\n  renderEffect: createCallbackLabel('createRenderEffect', true),\n  mount: createCallbackLabel('onMount'),\n  cleanup: createCallbackLabel('onCleanup'),\n  error: createCallbackLabel('onError'),\n  root: createCallbackLabel('createRoot'),\n  untrack: createCallbackLabel('untrack'),\n  batch: createCallbackLabel('batch'),\n  transition: createCallbackLabel('startTransition'),\n};\n\nconst LABEL_PARSER: Visitor<State> = {\n  LabeledStatement(path, state) {\n    if (path.node.label.name in EXPRESSIONS) {\n      EXPRESSIONS[path.node.label.name](state, path);\n    }\n  },\n};\n\nexport default LABEL_PARSER;\n", "import { addNamed } from '@babel/helper-module-imports';\nimport { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { ImportHook } from './types';\n\nexport default function getHookIdentifier(\n  hooks: ImportHook,\n  path: NodePath,\n  name: string,\n): t.Identifier {\n  const current = hooks.get(name);\n  if (current) {\n    return current;\n  }\n  const newID = addNamed(path, name, 'solid-js');\n  hooks.set(name, newID);\n  return newID;\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport accessorVariableExpression from './accessor-variable';\nimport normalizeAccessor from './normalize-accessor';\nimport { State } from './types';\n\nexport default function memoVariableExpression(\n  state: State,\n  path: NodePath<t.VariableDeclarator>,\n  memoIdentifier: t.Identifier,\n  stateIdentifier: t.Expression,\n  optionsIdentifier?: t.Expression,\n): void {\n  const normalIdentifier = normalizeAccessor(stateIdentifier);\n\n  if (state.opts.dev) {\n    if (optionsIdentifier) {\n      accessorVariableExpression(\n        state,\n        path,\n        memoIdentifier,\n        'createMemo',\n        [\n          normalIdentifier,\n          t.identifier('undefined'),\n          t.callExpression(\n            t.memberExpression(\n              t.identifier('Object'),\n              t.identifier('assign'),\n            ),\n            [\n              t.objectExpression([\n                t.objectProperty(\n                  t.identifier('name'),\n                  t.stringLiteral(memoIdentifier.name),\n                ),\n              ]),\n              optionsIdentifier,\n            ],\n          ),\n        ],\n      );\n    } else {\n      accessorVariableExpression(\n        state,\n        path,\n        memoIdentifier,\n        'createMemo',\n        [\n          normalIdentifier,\n          t.identifier('undefined'),\n          t.objectExpression([\n            t.objectProperty(\n              t.identifier('name'),\n              t.stringLiteral(memoIdentifier.name),\n            ),\n          ]),\n        ],\n      );\n    }\n  } else if (optionsIdentifier) {\n    accessorVariableExpression(\n      state,\n      path,\n      memoIdentifier,\n      'createMemo',\n      [\n        normalIdentifier,\n        t.identifier('undefined'),\n        optionsIdentifier,\n      ],\n    );\n  } else {\n    accessorVariableExpression(\n      state,\n      path,\n      memoIdentifier,\n      'createMemo',\n      [\n        normalIdentifier,\n      ],\n    );\n  }\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport derefMemoExpression from './deref-memo-expression';\nimport getHookIdentifier from './get-hook-identifier';\nimport { State } from './types';\n\nexport default function accessorVariableExpression(\n  state: State,\n  path: NodePath<t.VariableDeclarator>,\n  accessorIdentifier: t.Identifier,\n  mod: string,\n  replacement: Array<t.Expression | t.SpreadElement | t.JSXNamespacedName | t.ArgumentPlaceholder>,\n): void {\n  const readIdentifier = path.scope.generateUidIdentifier(accessorIdentifier.name);\n\n  path.node.id = readIdentifier;\n  path.node.init = t.callExpression(\n    getHookIdentifier(state.hooks, path, mod),\n    replacement,\n  );\n\n  derefMemoExpression(\n    path,\n    accessorIdentifier,\n    readIdentifier,\n  );\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { unexpectedMissingParent, unexpectedType } from './errors';\nimport normalizeBindings from './normalize-bindings';\n\nexport default function derefMemoExpression(\n  path: NodePath,\n  memoIdentifier: t.Identifier,\n  readIdentifier: t.Identifier,\n): void {\n  const parent = path.scope.path;\n  if (parent) {\n    parent.traverse({\n      CallExpression(p) {\n        if (p.scope !== path.scope && p.scope.hasOwnBinding(memoIdentifier.name)) {\n          return;\n        }\n        if (!t.isIdentifier(p.node.callee)) {\n          return;\n        }\n        switch (p.node.callee.name) {\n          case '$refMemo':\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === memoIdentifier.name) {\n              p.replaceWith(\n                readIdentifier,\n              );\n            }\n            break;\n          case '$get':\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === memoIdentifier.name) {\n              p.replaceWith(\n                readIdentifier,\n              );\n            }\n            break;\n          case '$getter':\n          case '$property':\n            if (!p.parentPath) {\n              throw unexpectedMissingParent(p);\n            }\n            if (!t.isObjectProperty(p.parent)) {\n              throw unexpectedType(p, p.parent.type, 'ObjectProperty');\n            }\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === memoIdentifier.name) {\n              p.parentPath.replaceWith(\n                t.objectMethod(\n                  'get',\n                  p.parent.key,\n                  [],\n                  t.blockStatement([\n                    t.returnStatement(\n                      t.callExpression(\n                        readIdentifier,\n                        [],\n                      ),\n                    ),\n                  ]),\n                ),\n              );\n            }\n            break;\n          default:\n            break;\n        }\n      },\n      ...normalizeBindings(\n        path,\n        t.callExpression(\n          readIdentifier,\n          [],\n        ),\n        memoIdentifier,\n      ),\n    });\n  }\n}\n", "import { NodePath } from '@babel/traverse';\n\nexport function unexpectedType<T>(\n  path: NodePath<T>,\n  received: string,\n  expected: string,\n): Error {\n  return path.buildCodeFrameError(`Unexpected '${received}' (Expected: ${expected})`);\n}\n\nexport function unexpectedMissingParent<T>(\n  path: NodePath<T>,\n): Error {\n  return path.buildCodeFrameError('Unexpected missing parent.');\n}\n\nexport function unexpectedArgumentLength<T>(\n  path: NodePath<T>,\n  received: number,\n  expected: number,\n): Error {\n  return path.buildCodeFrameError(`Unexpected argument length of ${received} (Expected: ${expected})`);\n}\n\nexport function unexpectedAssignmentOperator<T>(\n  path: NodePath<T>,\n  received: string,\n  expected: string,\n): Error {\n  return path.buildCodeFrameError(`Unexpected assignment operator '${received}' (Expected: ${expected})`);\n}\n", "import { NodePath, Visitor } from '@babel/traverse';\nimport * as t from '@babel/types';\n\nexport default function normalizeBindings(\n  path: NodePath,\n  replacement: t.Expression,\n  targetIdentifier: t.Identifier,\n): Visitor {\n  return {\n    ObjectProperty(p) {\n      if (p.scope !== path.scope && p.scope.hasOwnBinding(targetIdentifier.name)) {\n        return;\n      }\n      if (\n        p.node.shorthand\n        && t.isIdentifier(p.node.key)\n        && p.node.key.name === targetIdentifier.name\n        && t.isIdentifier(p.node.value)\n        && p.node.value.name === targetIdentifier.name\n      ) {\n        p.replaceWith(\n          t.objectProperty(\n            targetIdentifier,\n            replacement,\n          ),\n        );\n      }\n    },\n    Identifier(p) {\n      if (p.node.name !== targetIdentifier.name) {\n        return;\n      }\n      if (p.scope !== path.scope && p.scope.hasOwnBinding(targetIdentifier.name)) {\n        return;\n      }\n      // { x }\n      if (t.isObjectMethod(p.parent) && p.parent.key === p.node) {\n        return;\n      }\n      if (t.isObjectProperty(p.parent) && p.parent.key === p.node) {\n        return;\n      }\n      // const x\n      if (t.isVariableDeclarator(p.parent)) {\n        if (p.parent.id === p.node) {\n          return;\n        }\n      }\n      // const [x]\n      if (t.isArrayPattern(p.parent) && p.parent.elements.includes(p.node)) {\n        return;\n      }\n      // (x) => {}\n      if (t.isArrowFunctionExpression(p.parent) && p.parent.params.includes(p.node)) {\n        return;\n      }\n      // function (x)\n      if (t.isFunctionExpression(p.parent) && p.parent.params.includes(p.node)) {\n        return;\n      }\n      if (t.isFunctionDeclaration(p.parent) && p.parent.params.includes(p.node)) {\n        return;\n      }\n      // x:\n      if (t.isLabeledStatement(p.parent) && p.parent.label === p.node) {\n        return;\n      }\n      // obj.x\n      if (t.isMemberExpression(p.parent) && p.parent.property === p.node) {\n        return;\n      }\n      // function x() {}\n      if (t.isFunctionDeclaration(p.parent) && p.parent.id === p.node) {\n        return;\n      }\n      // (y = x) => {}\n      // function z(y = x) {}\n      if (\n        t.isAssignmentPattern(p.parent)\n        && p.parent.left === p.node\n        && (\n          (\n            t.isArrowFunctionExpression(p.parentPath.parent)\n            && p.parentPath.parent.params.includes(p.parent)\n          )\n          || (\n            t.isFunctionDeclaration(p.parentPath.parent)\n            && p.parentPath.parent.params.includes(p.parent)\n          )\n          || (\n            t.isFunctionExpression(p.parentPath.parent)\n            && p.parentPath.parent.params.includes(p.parent)\n          )\n        )\n      ) {\n        return;\n      }\n      p.replaceWith(\n        replacement,\n      );\n    },\n  };\n}\n", "import * as t from '@babel/types';\n\nexport default function normalizeAccessor(\n  identifier: t.Expression,\n): t.Expression {\n  return (\n    t.isCallExpression(identifier)\n    && identifier.arguments.length === 0\n    && t.isExpression(identifier.callee)\n      ? identifier.callee\n      : t.arrowFunctionExpression(\n        [],\n        identifier,\n      )\n  );\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport derefSignalExpression from './deref-signal-expression';\nimport getHookIdentifier from './get-hook-identifier';\nimport { State } from './types';\n\nexport default function signalVariableExpression(\n  state: State,\n  path: NodePath<t.VariableDeclarator>,\n  signalIdentifier: t.Identifier,\n  stateIdentifier: t.Expression = t.identifier('undefined'),\n  optionsIdentifier?: t.Expression,\n): void {\n  const readIdentifier = path.scope.generateUidIdentifier(signalIdentifier.name);\n  const writeIdentifier = path.scope.generateUidIdentifier(`set${signalIdentifier.name}`);\n\n  path.node.id = t.arrayPattern([\n    readIdentifier,\n    writeIdentifier,\n  ]);\n  if (state.opts.dev) {\n    if (optionsIdentifier) {\n      path.node.init = t.callExpression(\n        getHookIdentifier(state.hooks, path, 'createSignal'),\n        [\n          stateIdentifier,\n          t.callExpression(\n            t.memberExpression(\n              t.identifier('Object'),\n              t.identifier('assign'),\n            ),\n            [\n              t.objectExpression([\n                t.objectProperty(\n                  t.identifier('name'),\n                  t.stringLiteral(signalIdentifier.name),\n                ),\n              ]),\n              optionsIdentifier,\n            ],\n          ),\n        ],\n      );\n    } else {\n      path.node.init = t.callExpression(\n        getHookIdentifier(state.hooks, path, 'createSignal'),\n        [\n          stateIdentifier,\n          t.objectExpression([\n            t.objectProperty(\n              t.identifier('name'),\n              t.stringLiteral(signalIdentifier.name),\n            ),\n          ]),\n        ],\n      );\n    }\n  } else if (optionsIdentifier) {\n    path.node.init = t.callExpression(\n      getHookIdentifier(state.hooks, path, 'createSignal'),\n      [\n        stateIdentifier,\n        optionsIdentifier,\n      ],\n    );\n  } else {\n    path.node.init = t.callExpression(\n      getHookIdentifier(state.hooks, path, 'createSignal'),\n      [\n        stateIdentifier,\n      ],\n    );\n  }\n\n  derefSignalExpression(\n    path,\n    signalIdentifier,\n    readIdentifier,\n    writeIdentifier,\n  );\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { unexpectedMissingParent, unexpectedType } from './errors';\nimport normalizeBindings from './normalize-bindings';\n\nexport default function derefSignalExpression(\n  path: NodePath,\n  signalIdentifier: t.Identifier,\n  readIdentifier: t.Identifier,\n  writeIdentifier: t.Identifier,\n): void {\n  const parent = path.scope.path;\n  if (parent) {\n    parent.traverse({\n      CallExpression(p) {\n        if (p.scope !== path.scope && p.scope.hasOwnBinding(signalIdentifier.name)) {\n          return;\n        }\n        if (!t.isIdentifier(p.node.callee)) {\n          return;\n        }\n        switch (p.node.callee.name) {\n          case '$refSignal':\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === signalIdentifier.name) {\n              p.replaceWith(\n                t.arrayExpression([\n                  readIdentifier,\n                  writeIdentifier,\n                ]),\n              );\n            }\n            break;\n          case '$get':\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === signalIdentifier.name) {\n              p.replaceWith(\n                readIdentifier,\n              );\n            }\n            break;\n          case '$set':\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === signalIdentifier.name) {\n              p.replaceWith(\n                writeIdentifier,\n              );\n            }\n            break;\n          case '$getter':\n            if (!p.parentPath) {\n              throw unexpectedMissingParent(p);\n            }\n            if (!t.isObjectProperty(p.parent)) {\n              throw unexpectedType(p, p.parent.type, 'ObjectProperty');\n            }\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === signalIdentifier.name) {\n              p.parentPath.replaceWith(\n                t.objectMethod(\n                  'get',\n                  p.parent.key,\n                  [],\n                  t.blockStatement([\n                    t.returnStatement(\n                      t.callExpression(\n                        readIdentifier,\n                        [],\n                      ),\n                    ),\n                  ]),\n                ),\n              );\n            }\n            break;\n          case '$setter': {\n            if (!p.parentPath) {\n              throw unexpectedMissingParent(p);\n            }\n            if (!t.isObjectProperty(p.parent)) {\n              throw unexpectedType(p, p.parent.type, 'ObjectProperty');\n            }\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            const param = p.scope.generateUidIdentifier('value');\n            if (p.node.arguments[0].name === signalIdentifier.name) {\n              p.parentPath.replaceWith(\n                t.objectMethod(\n                  'set',\n                  p.parent.key,\n                  [param],\n                  t.blockStatement([\n                    t.returnStatement(\n                      t.callExpression(\n                        writeIdentifier,\n                        [\n                          t.arrowFunctionExpression(\n                            [],\n                            param,\n                          ),\n                        ],\n                      ),\n                    ),\n                  ]),\n                ),\n              );\n            }\n          }\n            break;\n          case '$property': {\n            if (!p.parentPath) {\n              throw unexpectedMissingParent(p);\n            }\n            if (!t.isObjectProperty(p.parent)) {\n              throw unexpectedType(p, p.parent.type, 'ObjectProperty');\n            }\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            const param = p.scope.generateUidIdentifier('value');\n            if (p.node.arguments[0].name === signalIdentifier.name) {\n              p.parentPath.replaceWith(\n                t.objectMethod(\n                  'get',\n                  p.parent.key,\n                  [],\n                  t.blockStatement([\n                    t.returnStatement(\n                      t.callExpression(\n                        readIdentifier,\n                        [],\n                      ),\n                    ),\n                  ]),\n                ),\n              );\n              p.parentPath.insertAfter(\n                t.objectMethod(\n                  'set',\n                  p.parent.key,\n                  [param],\n                  t.blockStatement([\n                    t.returnStatement(\n                      t.callExpression(\n                        writeIdentifier,\n                        [\n                          t.arrowFunctionExpression(\n                            [],\n                            param,\n                          ),\n                        ],\n                      ),\n                    ),\n                  ]),\n                ),\n              );\n            }\n          }\n            break;\n          default:\n            break;\n        }\n      },\n      ...normalizeBindings(\n        path,\n        t.callExpression(\n          readIdentifier,\n          [],\n        ),\n        signalIdentifier,\n      ),\n      UpdateExpression(p) {\n        if (p.scope !== path.scope && p.scope.hasOwnBinding(signalIdentifier.name)) {\n          return;\n        }\n        if (t.isIdentifier(p.node.argument) && p.node.argument.name === signalIdentifier.name) {\n          const param = p.scope.generateUidIdentifier('current');\n          if (p.node.prefix) {\n            p.replaceWith(\n              t.callExpression(\n                writeIdentifier,\n                [\n                  t.arrowFunctionExpression(\n                    [param],\n                    t.binaryExpression(\n                      p.node.operator === '++' ? '+' : '-',\n                      param,\n                      t.numericLiteral(1),\n                    ),\n                  ),\n                ],\n              ),\n            );\n          } else {\n            p.replaceWith(\n              t.callExpression(\n                t.arrowFunctionExpression(\n                  [],\n                  t.blockStatement([\n                    t.variableDeclaration(\n                      'const',\n                      [\n                        t.variableDeclarator(\n                          param,\n                          t.callExpression(\n                            readIdentifier,\n                            [],\n                          ),\n                        ),\n                      ],\n                    ),\n                    t.expressionStatement(\n                      t.callExpression(\n                        writeIdentifier,\n                        [\n                          t.arrowFunctionExpression(\n                            [],\n                            t.binaryExpression(\n                              p.node.operator === '++' ? '+' : '-',\n                              param,\n                              t.numericLiteral(1),\n                            ),\n                          ),\n                        ],\n                      ),\n                    ),\n                    t.returnStatement(\n                      param,\n                    ),\n                  ]),\n                ),\n                [],\n              ),\n            );\n          }\n        }\n      },\n      AssignmentExpression(p) {\n        if (p.scope !== path.scope && p.scope.hasOwnBinding(signalIdentifier.name)) {\n          return;\n        }\n        const identifier = p.node.left;\n        const expression = p.node.right;\n        if (\n          t.isIdentifier(identifier)\n          && identifier.name === signalIdentifier.name\n        ) {\n          if (p.node.operator === '=') {\n            p.replaceWith(\n              t.callExpression(\n                writeIdentifier,\n                [\n                  t.arrowFunctionExpression(\n                    [],\n                    expression,\n                  ),\n                ],\n              ),\n            );\n          } else {\n            const param = p.scope.generateUidIdentifier('current');\n            p.replaceWith(\n              t.callExpression(\n                writeIdentifier,\n                [\n                  t.arrowFunctionExpression(\n                    [param],\n                    t.assignmentExpression(\n                      p.node.operator,\n                      param,\n                      expression,\n                    ),\n                  ),\n                ],\n              ),\n            );\n          }\n        }\n      },\n    });\n  }\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport accessorVariableExpression from './accessor-variable';\nimport normalizeAccessor from './normalize-accessor';\nimport { State } from './types';\n\nexport default function deferredVariableExpression(\n  state: State,\n  path: NodePath<t.VariableDeclarator>,\n  deferredIdentifier: t.Identifier,\n  stateIdentifier: t.Expression = t.identifier('undefined'),\n  optionsIdentifier?: t.Expression,\n): void {\n  const normalIdentifier = normalizeAccessor(stateIdentifier);\n  if (state.opts.dev) {\n    if (optionsIdentifier) {\n      accessorVariableExpression(\n        state,\n        path,\n        deferredIdentifier,\n        'createDeferred',\n        [\n          normalIdentifier,\n          t.callExpression(\n            t.memberExpression(\n              t.identifier('Object'),\n              t.identifier('assign'),\n            ),\n            [\n              t.objectExpression([\n                t.objectProperty(\n                  t.identifier('name'),\n                  t.stringLiteral(deferredIdentifier.name),\n                ),\n              ]),\n              optionsIdentifier,\n            ],\n          ),\n        ],\n      );\n    } else {\n      accessorVariableExpression(\n        state,\n        path,\n        deferredIdentifier,\n        'createDeferred',\n        [\n          normalIdentifier,\n          t.objectExpression([\n            t.objectProperty(\n              t.identifier('name'),\n              t.stringLiteral(deferredIdentifier.name),\n            ),\n          ]),\n        ],\n      );\n    }\n  } else if (optionsIdentifier) {\n    accessorVariableExpression(\n      state,\n      path,\n      deferredIdentifier,\n      'createDeferred',\n      [\n        normalIdentifier,\n        optionsIdentifier,\n      ],\n    );\n  } else {\n    accessorVariableExpression(\n      state,\n      path,\n      deferredIdentifier,\n      'createDeferred',\n      [\n        normalIdentifier,\n      ],\n    );\n  }\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { unexpectedType } from './errors';\nimport getHookIdentifier from './get-hook-identifier';\nimport normalizeBindings from './normalize-bindings';\nimport { State } from './types';\n\nexport default function destructureVariableExpression(\n  state: State,\n  path: NodePath<t.VariableDeclarator>,\n  target: t.Expression,\n  pattern: t.ObjectPattern | t.ArrayPattern,\n  replace = true,\n): void {\n  const otherIdentifier = path.scope.generateUidIdentifier('other');\n\n  const properties: t.Expression[] = [];\n  let restIdentifier: t.Identifier | undefined;\n\n  if (t.isObjectPattern(pattern)) {\n    for (let i = 0, len = pattern.properties.length; i < len; i += 1) {\n      const property = pattern.properties[i];\n      if (t.isObjectProperty(property)) {\n        const { value, key } = property;\n\n        if (!property.computed) {\n          if (t.isIdentifier(key)) {\n            properties.push(t.stringLiteral(key.name));\n          }\n        } else {\n          properties.push(key);\n        }\n\n        const newIdentifier = path.scope.generateUidIdentifier('prop');\n        path.insertBefore(\n          t.variableDeclarator(\n            newIdentifier,\n            t.arrowFunctionExpression(\n              [],\n              t.memberExpression(\n                target,\n                key,\n                property.computed,\n              ),\n            ),\n          ),\n        );\n\n        if (t.isObjectPattern(value) || t.isArrayPattern(value)) {\n          destructureVariableExpression(\n            state,\n            path,\n            t.callExpression(newIdentifier, []),\n            value,\n            false,\n          );\n        } else if (t.isIdentifier(value)) {\n          path.scope.path.traverse(normalizeBindings(\n            path.scope.path,\n            t.callExpression(newIdentifier, []),\n            value,\n          ));\n        } else if (t.isAssignmentPattern(value)) {\n          // TODO\n        } else {\n          throw unexpectedType(path, value.type, 'Identifier | ObjectPattern | ArrayPattern');\n        }\n      } else if (t.isIdentifier(property.argument)) {\n        restIdentifier = property.argument;\n      }\n    }\n  } else {\n    for (let i = 0, len = pattern.elements.length; i < len; i += 1) {\n      const property = pattern.elements[i];\n      if (property) {\n        const keyExpr = t.numericLiteral(i);\n\n        const newIdentifier = path.scope.generateUidIdentifier('prop');\n        path.insertBefore(\n          t.variableDeclarator(\n            newIdentifier,\n            t.arrowFunctionExpression(\n              [],\n              t.memberExpression(\n                target,\n                keyExpr,\n                true,\n              ),\n            ),\n          ),\n        );\n\n        properties.push(keyExpr);\n\n        if (t.isIdentifier(property)) {\n          path.scope.path.traverse(normalizeBindings(\n            path.scope.path,\n            t.callExpression(newIdentifier, []),\n            property,\n          ));\n        } else if (t.isArrayPattern(property) || t.isObjectPattern(property)) {\n          destructureVariableExpression(\n            state,\n            path,\n            t.callExpression(newIdentifier, []),\n            property,\n            false,\n          );\n        } else if (t.isRestElement(property)) {\n          if (t.isIdentifier(property.argument)) {\n            restIdentifier = property.argument;\n          }\n        } else {\n          // TODO AssignmentExpresison\n        }\n      }\n    }\n  }\n\n  const expr = t.variableDeclarator(\n    otherIdentifier,\n    (\n      properties.length\n        ? (\n          t.memberExpression(\n            t.callExpression(\n              getHookIdentifier(state.hooks, path, 'splitProps'),\n              [target, t.arrayExpression(properties)],\n            ),\n            t.numericLiteral(1),\n            true,\n          )\n        )\n        : target\n    ),\n  );\n\n  if (replace) {\n    path.replaceWith(expr);\n  } else {\n    path.insertAfter(expr);\n  }\n\n  if (restIdentifier) {\n    path.scope.path.traverse(normalizeBindings(\n      path.scope.path,\n      otherIdentifier,\n      restIdentifier,\n    ));\n  }\n}\n", "import { NodePath, Visitor } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport accessorVariableExpression from './accessor-variable';\nimport deferredVariableExpression from './deferred-variable';\nimport getHookIdentifier from './get-hook-identifier';\nimport memoVariableExpression from './memo-variable';\nimport signalVariableExpression from './signal-variable';\nimport destructureVariableExpression from './destructure-variable';\nimport { State } from './types';\n\nfunction signalExpression(\n  state: State,\n  path: NodePath<t.VariableDeclaration>,\n): void {\n  path.traverse({\n    VariableDeclarator(p) {\n      const leftExpr = p.node.id;\n      const rightExpr = p.node.init;\n      if (t.isIdentifier(leftExpr)) {\n        signalVariableExpression(state, p, leftExpr, rightExpr ?? undefined);\n      }\n    },\n  });\n}\n\nfunction memoExpression(\n  state: State,\n  path: NodePath<t.VariableDeclaration>,\n): void {\n  path.traverse({\n    VariableDeclarator(p) {\n      const leftExpr = p.node.id;\n      const rightExpr = p.node.init;\n      if (t.isIdentifier(leftExpr)) {\n        memoVariableExpression(state, p, leftExpr, rightExpr ?? t.identifier('undefined'));\n      }\n    },\n  });\n}\n\nfunction destructureExpression(\n  state: State,\n  path: NodePath<t.VariableDeclaration>,\n): void {\n  path.traverse({\n    VariableDeclarator(p) {\n      const leftExpr = p.node.id;\n      const rightExpr = p.node.init;\n      if ((t.isObjectPattern(leftExpr) || t.isArrayPattern(leftExpr)) && rightExpr) {\n        destructureVariableExpression(\n          state,\n          p,\n          rightExpr,\n          leftExpr,\n        );\n      }\n    },\n  });\n}\n\nfunction deferredExpression(\n  state: State,\n  path: NodePath<t.VariableDeclaration>,\n): void {\n  path.traverse({\n    VariableDeclarator(p) {\n      const leftExpr = p.node.id;\n      const rightExpr = p.node.init;\n      if (t.isIdentifier(leftExpr)) {\n        deferredVariableExpression(state, p, leftExpr, rightExpr ?? t.identifier('undefined'));\n      }\n    },\n  });\n}\n\nfunction childrenExpression(\n  state: State,\n  path: NodePath<t.VariableDeclaration>,\n): void {\n  path.traverse({\n    VariableDeclarator(p) {\n      const leftExpr = p.node.id;\n      const rightExpr = p.node.init;\n      if (t.isIdentifier(leftExpr)) {\n        accessorVariableExpression(\n          state,\n          p,\n          leftExpr,\n          'children',\n          [\n            t.arrowFunctionExpression(\n              [],\n              rightExpr ?? t.identifier('undefined'),\n            ),\n          ],\n        );\n      }\n    },\n  });\n}\n\nfunction createCallbackLabel(label: string, named = false) {\n  return function expr(\n    state: State,\n    path: NodePath<t.BlockStatement | t.ExpressionStatement>,\n    name?: string,\n  ): void {\n    const body = path.node;\n    let callback: t.Expression;\n    if (t.isBlockStatement(body)) {\n      callback = t.arrowFunctionExpression(\n        [],\n        body,\n      );\n    } else {\n      callback = body.expression;\n    }\n    if (named && name) {\n      path.replaceWith(\n        t.callExpression(\n          getHookIdentifier(state.hooks, path, label),\n          [\n            callback,\n            t.identifier('undefined'),\n            t.objectExpression([\n              t.objectProperty(\n                t.identifier('name'),\n                t.stringLiteral(name),\n              ),\n            ]),\n          ],\n        ),\n      );\n    } else {\n      path.replaceWith(\n        t.callExpression(\n          getHookIdentifier(state.hooks, path, label),\n          [\n            callback,\n          ],\n        ),\n      );\n    }\n  };\n}\n\ntype CallbackLabelExpresion = (\n  state: State,\n  path: NodePath<t.BlockStatement | t.ExpressionStatement>,\n  name: string | undefined,\n) => void;\n\ntype StateExpression = (\n  state: State,\n  path: NodePath<t.VariableDeclaration>,\n) => void;\n\nconst STATE_EXPRESSIONS: Record<string, StateExpression> = {\n  '@signal': signalExpression,\n  '@memo': memoExpression,\n  '@children': childrenExpression,\n  '@deferred': deferredExpression,\n  '@destructure': destructureExpression,\n};\n\nconst CALLBACK_EXPRESSIONS: Record<string, CallbackLabelExpresion> = {\n  '@effect': createCallbackLabel('createEffect', true),\n  '@computed': createCallbackLabel('createComputed', true),\n  '@renderEffect': createCallbackLabel('createRenderEffect', true),\n  '@mount': createCallbackLabel('onMount'),\n  '@cleanup': createCallbackLabel('onCleanup'),\n  '@error': createCallbackLabel('onError'),\n  '@root': createCallbackLabel('createRoot'),\n  '@untrack': createCallbackLabel('untrack'),\n  '@batch': createCallbackLabel('batch'),\n  '@transition': createCallbackLabel('startTransition'),\n};\n\nconst COMMENT_PARSER: Visitor<State> = {\n  VariableDeclaration(path, state) {\n    const comments = path.node.leadingComments;\n    if (comments) {\n      let preference: string | undefined;\n      for (let i = 0, len = comments.length; i < len; i += 1) {\n        const comment: t.Comment = comments[i];\n        const value: string = comment.value.trim();\n        if (value in STATE_EXPRESSIONS) {\n          preference = value;\n          comment.value = '';\n        }\n      }\n      if (preference) {\n        STATE_EXPRESSIONS[preference](state, path);\n      }\n    }\n  },\n  BlockStatement(path, state) {\n    if (\n      t.isFunctionDeclaration(path.parent)\n    ) {\n      return;\n    }\n    const comments = path.node.leadingComments;\n    if (comments) {\n      let preference: string | undefined;\n      let name: string | undefined;\n      for (let i = 0, len = comments.length; i < len; i += 1) {\n        const comment: t.Comment = comments[i];\n        const value: string = comment.value.trim();\n        if (/^@\\w+( .*)?$/.test(value)) {\n          const [tag, ...debugName] = value.split(' ');\n          if (tag in CALLBACK_EXPRESSIONS) {\n            preference = tag;\n            name = debugName.join(' ');\n            comment.value = '';\n          }\n        }\n      }\n      if (preference) {\n        CALLBACK_EXPRESSIONS[preference](state, path, name);\n      }\n    }\n  },\n  ExpressionStatement(path, state) {\n    const comments = path.node.leadingComments;\n    if (comments) {\n      let preference: string | undefined;\n      let name: string | undefined;\n      for (let i = 0, len = comments.length; i < len; i += 1) {\n        const comment: t.Comment = comments[i];\n        const value: string = comment.value.trim();\n        if (/^@\\w+( .*)?$/.test(value)) {\n          const [tag, ...debugName] = value.split(' ');\n          if (tag in CALLBACK_EXPRESSIONS) {\n            preference = tag;\n            name = debugName.join(' ');\n            comment.value = '';\n          }\n        }\n      }\n      if (preference) {\n        CALLBACK_EXPRESSIONS[preference](state, path, name);\n      }\n    }\n  },\n};\n\nexport default COMMENT_PARSER;\n", "import { NodePath, Visitor } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport getHookIdentifier from './get-hook-identifier';\nimport { State } from './types';\nimport {\n  unexpectedArgumentLength,\n  unexpectedMissingParent,\n  unexpectedType,\n} from './errors';\nimport derefSignalVariableExpression from './deref-signal-variable';\nimport derefMemoVariableExpression from './deref-memo-variable';\nimport memoVariableExpression from './memo-variable';\nimport signalVariableExpression from './signal-variable';\nimport accessorVariableExpression from './accessor-variable';\nimport deferredVariableExpression from './deferred-variable';\nimport destructureVariableExpression from './destructure-variable';\nimport normalizeAccessor from './normalize-accessor';\n\nfunction derefSignalExpression(\n  _: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 1) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!t.isIdentifier(leftExpr)) {\n    throw unexpectedType(path.parentPath, leftExpr.type, 'Identifier');\n  }\n  derefSignalVariableExpression(\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    leftExpr,\n    argument,\n  );\n}\n\nfunction signalExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 2) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 2);\n  }\n  let argument: t.Expression | undefined;\n  let options: t.Expression | undefined;\n  if (path.node.arguments.length > 0) {\n    const initialState = path.node.arguments[0];\n    if (!t.isExpression(initialState)) {\n      throw unexpectedType(path, initialState.type, 'Expression');\n    }\n    argument = initialState;\n    if (path.node.arguments.length > 1) {\n      const optionsValue = path.node.arguments[1];\n      if (!t.isExpression(optionsValue)) {\n        throw unexpectedType(path, optionsValue.type, 'Expression');\n      }\n      options = optionsValue;\n    }\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!t.isIdentifier(leftExpr)) {\n    throw unexpectedType(path.parentPath, leftExpr.type, 'Identifier');\n  }\n  signalVariableExpression(\n    state,\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    leftExpr,\n    argument,\n    options,\n  );\n}\n\nfunction derefMemoExpression(\n  _: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 1) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!t.isIdentifier(leftExpr)) {\n    throw unexpectedType(path.parentPath, leftExpr.type, 'Expression');\n  }\n  derefMemoVariableExpression(\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    leftExpr,\n    argument,\n  );\n}\n\nfunction memoExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 2) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 2);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  let options: t.Expression | undefined;\n  if (path.node.arguments.length > 1) {\n    const optionsValue = path.node.arguments[1];\n    if (!t.isExpression(optionsValue)) {\n      throw unexpectedType(path, optionsValue.type, 'Expression');\n    }\n    options = optionsValue;\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!t.isIdentifier(leftExpr)) {\n    throw unexpectedType(path.parentPath, leftExpr.type, 'Expression');\n  }\n  memoVariableExpression(\n    state,\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    leftExpr,\n    argument,\n    options,\n  );\n}\n\nfunction deferredExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 2) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 2);\n  }\n  let argument: t.Expression | undefined;\n  let options: t.Expression | undefined;\n  if (path.node.arguments.length > 0) {\n    const initialState = path.node.arguments[0];\n    if (!t.isExpression(initialState)) {\n      throw unexpectedType(path, initialState.type, 'Expression');\n    }\n    argument = initialState;\n    if (path.node.arguments.length > 1) {\n      const optionsValue = path.node.arguments[1];\n      if (!t.isExpression(optionsValue)) {\n        throw unexpectedType(path, optionsValue.type, 'Expression');\n      }\n      options = optionsValue;\n    }\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!t.isIdentifier(leftExpr)) {\n    throw unexpectedType(path, leftExpr.type, 'Identifier');\n  }\n  deferredVariableExpression(\n    state,\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    leftExpr,\n    argument,\n    options,\n  );\n}\n\nfunction reactiveExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 1) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (t.isVariableDeclarator(path.parent)) {\n    const leftExpr = path.parent.id;\n    if (!t.isIdentifier(leftExpr)) {\n      throw unexpectedType(path, leftExpr.type, 'Identifier');\n    }\n    memoVariableExpression(\n      state,\n      path.parentPath as NodePath<t.VariableDeclarator>,\n      leftExpr,\n      argument,\n    );\n  } else if (t.isExpressionStatement(path.parent)) {\n    path.replaceWith(\n      t.callExpression(\n        getHookIdentifier(state.hooks, path, 'createEffect'),\n        [\n          t.arrowFunctionExpression(\n            [],\n            argument,\n          ),\n        ],\n      ),\n    );\n  } else {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator | ExpressionStatement');\n  }\n}\n\nfunction rootExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 1) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  const arrow = (\n    (t.isArrowFunctionExpression(argument) || t.isFunctionExpression(argument))\n      ? argument\n      : (\n        t.arrowFunctionExpression(\n          [],\n          argument,\n        )\n      )\n  );\n  path.replaceWith(\n    t.callExpression(\n      getHookIdentifier(state.hooks, path, 'createRoot'),\n      [\n        arrow,\n      ],\n    ),\n  );\n}\n\nfunction fromExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 1) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!t.isIdentifier(leftExpr)) {\n    throw unexpectedType(path, leftExpr.type, 'Identifier');\n  }\n  accessorVariableExpression(\n    state,\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    leftExpr,\n    'from',\n    [\n      argument,\n    ],\n  );\n}\n\nfunction createCompileTimeAutoAccessor(target: string, limit: number) {\n  return (\n    state: State,\n    path: NodePath<t.CallExpression>,\n  ) => {\n    if (path.node.arguments.length > limit) {\n      throw unexpectedArgumentLength(path, path.node.arguments.length, limit);\n    }\n    const [argument, ...rest] = path.node.arguments;\n    if (!t.isExpression(argument)) {\n      throw unexpectedType(path, argument.type, 'Expression');\n    }\n    if (!path.parentPath) {\n      throw unexpectedMissingParent(path);\n    }\n    if (!t.isVariableDeclarator(path.parent)) {\n      throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n    }\n    const leftExpr = path.parent.id;\n    if (!t.isIdentifier(leftExpr)) {\n      throw unexpectedType(path, leftExpr.type, 'Identifier');\n    }\n    accessorVariableExpression(\n      state,\n      path.parentPath as NodePath<t.VariableDeclarator>,\n      leftExpr,\n      target,\n      [\n        normalizeAccessor(argument),\n        ...rest,\n      ],\n    );\n  };\n}\n\ntype CompileTimeFunctionExpression = (\n  state: State,\n  path: NodePath<t.CallExpression>,\n) => void;\n\nfunction createCompileTimeAlias(target: string) {\n  return (\n    state: State,\n    path: NodePath<t.CallExpression>,\n  ) => {\n    path.node.callee = getHookIdentifier(state.hooks, path, target);\n  };\n}\n\nfunction createCompileTimeAutoArrow(target: string, limit: number) {\n  return (\n    state: State,\n    path: NodePath<t.CallExpression>,\n  ) => {\n    if (path.node.arguments.length > limit) {\n      throw unexpectedArgumentLength(path, path.node.arguments.length, limit);\n    }\n    const [argument, ...rest] = path.node.arguments;\n    if (!t.isExpression(argument)) {\n      throw unexpectedType(path, argument.type, 'Expression');\n    }\n    path.replaceWith(\n      t.callExpression(\n        getHookIdentifier(state.hooks, path, target),\n        [\n          normalizeAccessor(argument),\n          ...rest,\n        ],\n      ),\n    );\n  };\n}\n\nfunction destructureExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 1) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!(t.isObjectPattern(leftExpr) || t.isArrayPattern(leftExpr))) {\n    throw unexpectedType(path, leftExpr.type, 'ArrayPattern | ObjectPattern');\n  }\n  destructureVariableExpression(\n    state,\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    argument,\n    leftExpr,\n  );\n}\n\nconst CTF_EXPRESSIONS: Record<string, CompileTimeFunctionExpression> = {\n  $: reactiveExpression,\n  $derefSignal: derefSignalExpression,\n  $derefMemo: derefMemoExpression,\n  $signal: signalExpression,\n  $memo: memoExpression,\n  $root: rootExpression,\n  $from: fromExpression,\n  $deferred: deferredExpression,\n\n  // auto accessors + auto arrow\n  $children: createCompileTimeAutoAccessor('children', 1),\n  $mapArray: createCompileTimeAutoAccessor('mapArray', 3),\n  $indexArray: createCompileTimeAutoAccessor('indexArray', 3),\n\n  // auto arrows\n  $lazy: createCompileTimeAutoArrow('lazy', 1),\n  $untrack: createCompileTimeAutoArrow('untrack', 1),\n  $batch: createCompileTimeAutoArrow('batch', 1),\n  $observable: createCompileTimeAutoArrow('observable', 1),\n  $selector: createCompileTimeAutoArrow('createSelector', 1),\n  $on: createCompileTimeAutoArrow('on', 3),\n\n  // aliases\n  $useContext: createCompileTimeAlias('useContext'),\n  $createContext: createCompileTimeAlias('createContext'),\n  $uid: createCompileTimeAlias('createUniqueId'),\n  $effect: createCompileTimeAlias('createEffect'),\n  $computed: createCompileTimeAlias('createComputed'),\n  $renderEffect: createCompileTimeAlias('createRenderEffect'),\n  $merge: createCompileTimeAlias('mergeProps'),\n\n  $destructure: destructureExpression,\n};\n\nconst CTF_PARSER: Visitor<State> = {\n  CallExpression(path, state) {\n    if (\n      t.isIdentifier(path.node.callee)\n      && path.node.callee.name in CTF_EXPRESSIONS\n    ) {\n      CTF_EXPRESSIONS[path.node.callee.name](state, path);\n    }\n  },\n};\n\nexport default CTF_PARSER;\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport derefSignalExpression from './deref-signal-expression';\n\nexport default function derefSignalVariableExpression(\n  path: NodePath<t.VariableDeclarator>,\n  signalIdentifier: t.Identifier,\n  stateIdentifier: t.Expression,\n): void {\n  const readIdentifier = path.scope.generateUidIdentifier(signalIdentifier.name);\n  const writeIdentifier = path.scope.generateUidIdentifier(`set${signalIdentifier.name}`);\n\n  path.node.id = t.arrayPattern([\n    readIdentifier,\n    writeIdentifier,\n  ]);\n  path.node.init = stateIdentifier;\n\n  derefSignalExpression(\n    path,\n    signalIdentifier,\n    readIdentifier,\n    writeIdentifier,\n  );\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport derefMemoExpression from './deref-memo-expression';\n\nexport default function derefMemoVariableExpression(\n  path: NodePath<t.VariableDeclarator>,\n  memoIdentifier: t.Identifier,\n  stateIdentifier: t.Expression,\n): void {\n  const readIdentifier = path.scope.generateUidIdentifier(memoIdentifier.name);\n\n  path.node.id = readIdentifier;\n  path.node.init = stateIdentifier;\n\n  derefMemoExpression(\n    path,\n    memoIdentifier,\n    readIdentifier,\n  );\n}\n", "import { PluginObj } from '@babel/core';\nimport * as solid from 'solid-js';\nimport { State } from './types';\nimport LABEL_PARSER from './label-parser';\nimport COMMENT_PARSER from './comment-parser';\nimport CTF_PARSER from './ctf-parser';\n\ntype BoxedTupleTypes<T extends any[]> =\n  { [P in keyof T]: [T[P]] }[Exclude<keyof T, keyof any[]>]\ntype UnionToIntersection<U> =\n  (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\ntype UnboxIntersection<T> = T extends { 0: infer U } ? U : never;\ntype MergeProps<T extends any[]> = UnboxIntersection<UnionToIntersection<BoxedTupleTypes<T>>>;\n\ndeclare global {\n  type Accessor<T> = solid.Accessor<T>;\n  type Setter<T> = solid.Setter<T>;\n  type Context<T> = solid.Context<T>;\n  type ObservableObserver<T> = solid.ObservableObserver<T>;\n  type Component<T> = solid.Component<T>;\n\n  function $signal<T>(): T | undefined;\n  function $signal<T>(\n    value: T,\n    options?: {\n      equals?: false | ((prev: T, next: T) => boolean);\n      name?: string;\n      internal?: boolean,\n    }\n  ): T;\n\n  function $memo<T>(\n    value: T,\n    options?: { equals?: false | ((prev: T, next: T) => boolean); name?: string }\n  ): T;\n  function $memo<T>(\n    value: T,\n    options?: { equals?: false | ((prev: T, next: T) => boolean); name?: string }\n  ): T;\n\n  function $untrack<T>(value: T): T;\n  function $batch<T>(value: T): T;\n\n  function $derefSignal<T>(value: [Accessor<T>, Setter<T>]): T;\n  function $refSignal<T>(value: T): [Accessor<T>, Setter<T>];\n  function $derefMemo<T>(value: Accessor<T>): T;\n  function $refMemo<T>(value: T): Accessor<T>;\n\n  function $<T>(value: T): T;\n\n  function $get<T>(value: T): Accessor<T>;\n  function $set<T>(value: T): Setter<T>;\n\n  function $effect<T>(fn: (v?: T) => T | undefined): void;\n  function $effect<T>(fn: (v: T) => T, value: T, options?: { name?: string }): void;\n\n  function $computed<T>(fn: (v?: T) => T | undefined): void;\n  function $computed<T>(fn: (v: T) => T, value: T, options?: { name?: string }): void;\n\n  function $renderEffect<T>(fn: (v?: T) => T | undefined): void;\n  function $renderEffect<T>(fn: (v: T) => T, value: T, options?: { name?: string }): void;\n\n  function $root<T>(value: T): T;\n  function $root<T>(cb: (dispose: () => void) => T): T;\n\n  function $selector<T, U>(\n    source: T,\n    fn?: (a: U, b: T) => boolean,\n    options?: { name?: string }\n  ): (key: U) => boolean;\n\n  function $on<T, U>(\n    deps: T,\n    fn: (input: T, prevInput: T, prevValue?: U) => U,\n    options?: { defer?: boolean }\n  ): (prevValue?: U) => U;\n\n  function $deferred<T>(\n    source: T,\n    options?: {\n      equals?: false | ((prev: T, next: T) => boolean);\n      name?: string;\n      timeoutMs?: number;\n    },\n  ): T;\n\n  function $uid(): string;\n\n  function $createContext<T>(): Context<T | undefined>;\n  function $createContext<T>(defaultValue: T): Context<T>;\n  function $useContext<T>(context: Context<T>): T;\n\n  function $lazy<T extends Component<any>>(fn: Promise<{ default: T }>): T & {\n    preload: () => void;\n  };\n\n  function $children(value: solid.JSX.Element): solid.JSX.Element;\n\n  interface Observable<T> {\n    subscribe(observer: ObservableObserver<T>): { unsubscribe(): void } | (() => void);\n  }\n\n  function $observable<T>(value: T): Observable<T>;\n\n  function $from<T>(observable: Observable<T>): T;\n  function $from<T>(produce: ((setter: Setter<T>) => () => void)): T;\n\n  function $mapArray<T, U>(\n    arr: readonly T[] | undefined | null | false,\n    mapFn: (v: T, i: Accessor<number>) => U,\n    options?: {\n      fallback?: Accessor<any>;\n    },\n  ): U[];\n  function $indexArray<T, U>(\n    arr: readonly T[] | undefined | null | false,\n    mapFn: (v: Accessor<T>, i: number) => U,\n    options?: {\n      fallback?: Accessor<any>;\n    },\n  ): U[];\n\n  function $merge<T extends any[]>(...args: T): MergeProps<T>;\n  function $destructure<T>(value: T): T;\n\n  function $getter<T>(value: T): T;\n  function $setter<T>(value: T): T;\n  function $property<T>(value: T): T;\n}\n\nexport default function solidReactivityPlugin(): PluginObj<State> {\n  return {\n    pre() {\n      this.hooks = new Map();\n    },\n    visitor: {\n      ...LABEL_PARSER,\n      ...COMMENT_PARSER,\n      ...CTF_PARSER,\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": []
}

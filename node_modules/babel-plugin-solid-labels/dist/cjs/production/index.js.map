{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/label-parser.ts", "../../../src/get-hook-identifier.ts", "../../../src/memo-variable.ts", "../../../src/accessor-variable.ts", "../../../src/deref-memo-expression.ts", "../../../src/errors.ts", "../../../src/normalize-bindings.ts", "../../../src/normalize-accessor.ts", "../../../src/signal-variable.ts", "../../../src/deref-signal-expression.ts", "../../../src/deferred-variable.ts", "../../../src/destructure-variable.ts", "../../../src/comment-parser.ts", "../../../src/ctf-parser.ts", "../../../src/deref-signal-variable.ts", "../../../src/deref-memo-variable.ts", "../../../src/auto-import.ts"],
  "sourcesContent": ["import { PluginObj } from '@babel/core';\nimport * as solid from 'solid-js';\nimport * as solidWeb from 'solid-js/web';\nimport * as solidStore from 'solid-js/store';\nimport { State } from './types';\nimport LABEL_PARSER from './label-parser';\nimport COMMENT_PARSER from './comment-parser';\nimport CTF_PARSER from './ctf-parser';\nimport AUTO_IMPORT_EXPR from './auto-import';\n\ntype BoxedTupleTypes<T extends any[]> =\n  { [P in keyof T]: [T[P]] }[Exclude<keyof T, keyof any[]>]\ntype UnionToIntersection<U> =\n  (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\ntype UnboxIntersection<T> = T extends { 0: infer U } ? U : never;\ntype MergeProps<T extends any[]> = UnboxIntersection<UnionToIntersection<BoxedTupleTypes<T>>>;\n\ndeclare global {\n  type Accessor<T> = solid.Accessor<T>;\n  type Setter<T> = solid.Setter<T>;\n  type Context<T> = solid.Context<T>;\n  type ObservableObserver<T> = solid.ObservableObserver<T>;\n  type Component<T> = solid.Component<T>;\n\n  function $signal<T>(): T | undefined;\n  function $signal<T>(\n    value: T,\n    options?: {\n      equals?: false | ((prev: T, next: T) => boolean);\n      name?: string;\n      internal?: boolean,\n    }\n  ): T;\n\n  function $memo<T>(\n    value: T,\n    options?: { equals?: false | ((prev: T, next: T) => boolean); name?: string }\n  ): T;\n  function $memo<T>(\n    value: T,\n    options?: { equals?: false | ((prev: T, next: T) => boolean); name?: string }\n  ): T;\n\n  function $untrack<T>(value: T): T;\n  function $batch<T>(value: T): T;\n\n  function $derefSignal<T>(value: [Accessor<T>, Setter<T>]): T;\n  function $refSignal<T>(value: T): [Accessor<T>, Setter<T>];\n  function $derefMemo<T>(value: Accessor<T>): T;\n  function $refMemo<T>(value: T): Accessor<T>;\n\n  function $<T>(value: T): T;\n\n  function $get<T>(value: T): Accessor<T>;\n  function $set<T>(value: T): Setter<T>;\n\n  function $effect<T>(fn: (v?: T) => T | undefined): void;\n  function $effect<T>(fn: (v: T) => T, value: T, options?: { name?: string }): void;\n\n  function $computed<T>(fn: (v?: T) => T | undefined): void;\n  function $computed<T>(fn: (v: T) => T, value: T, options?: { name?: string }): void;\n\n  function $renderEffect<T>(fn: (v?: T) => T | undefined): void;\n  function $renderEffect<T>(fn: (v: T) => T, value: T, options?: { name?: string }): void;\n\n  function $root<T>(value: T): T;\n  function $root<T>(cb: (dispose: () => void) => T): T;\n\n  function $selector<T, U>(\n    source: T,\n    fn?: (a: U, b: T) => boolean,\n    options?: { name?: string }\n  ): (key: U) => boolean;\n\n  function $on<T, U>(\n    deps: T,\n    fn: (input: T, prevInput: T, prevValue?: U) => U,\n    options?: { defer?: boolean }\n  ): (prevValue?: U) => U;\n\n  function $deferred<T>(\n    source: T,\n    options?: {\n      equals?: false | ((prev: T, next: T) => boolean);\n      name?: string;\n      timeoutMs?: number;\n    },\n  ): T;\n\n  function $uid(): string;\n\n  function $createContext<T>(): Context<T | undefined>;\n  function $createContext<T>(defaultValue: T): Context<T>;\n  function $useContext<T>(context: Context<T>): T;\n\n  function $lazy<T extends Component<any>>(fn: Promise<{ default: T }>): T & {\n    preload: () => void;\n  };\n\n  function $children(value: solid.JSX.Element): solid.JSX.Element;\n\n  interface Observable<T> {\n    subscribe(observer: ObservableObserver<T>): { unsubscribe(): void } | (() => void);\n  }\n\n  function $observable<T>(value: T): Observable<T>;\n\n  function $from<T>(observable: Observable<T>): T;\n  function $from<T>(produce: ((setter: Setter<T>) => () => void)): T;\n\n  function $mapArray<T, U>(\n    arr: readonly T[] | undefined | null | false,\n    mapFn: (v: T, i: Accessor<number>) => U,\n    options?: {\n      fallback?: Accessor<any>;\n    },\n  ): U[];\n  function $indexArray<T, U>(\n    arr: readonly T[] | undefined | null | false,\n    mapFn: (v: Accessor<T>, i: number) => U,\n    options?: {\n      fallback?: Accessor<any>;\n    },\n  ): U[];\n\n  function $merge<T extends any[]>(...args: T): MergeProps<T>;\n  function $destructure<T>(value: T): T;\n\n  function $getter<T>(value: T): T;\n  function $setter<T>(value: T): T;\n  function $property<T>(value: T): T;\n\n  const $resource: typeof solid.createResource;\n\n  // store\n  const $store: typeof solidStore.createStore;\n  const $mutable: typeof solidStore.createMutable;\n  const $produce: typeof solidStore.produce;\n  const $reconcile: typeof solidStore.reconcile;\n\n  // components\n  const $for: typeof solid.For;\n  const $show: typeof solid.Show;\n  const $switch: typeof solid.Switch;\n  const $match: typeof solid.Match;\n  const $index: typeof solid.Index;\n  const $errorBoundary: typeof solid.ErrorBoundary;\n  const $suspense: typeof solid.Suspense;\n  const $suspenseList: typeof solid.SuspenseList;\n  const $dynamic: typeof solidWeb.Dynamic;\n  const $portal: typeof solidWeb.Portal;\n  const $assets: typeof solidWeb.Assets;\n  const $hydrationScript: typeof solidWeb.HydrationScript;\n  const $noHydration: typeof solidWeb.NoHydration;\n}\n\nexport default function solidReactivityPlugin(): PluginObj<State> {\n  return {\n    pre() {\n      this.hooks = new Map();\n    },\n    visitor: {\n      ...LABEL_PARSER,\n      ...COMMENT_PARSER,\n      ...CTF_PARSER,\n      ...AUTO_IMPORT_EXPR,\n    },\n  };\n}\n", "import { NodePath, Visitor } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport getHookIdentifier from './get-hook-identifier';\nimport memoVariableExpression from './memo-variable';\nimport signalVariableExpression from './signal-variable';\nimport accessorVariableExpression from './accessor-variable';\nimport { State } from './types';\nimport deferredVariableExpression from './deferred-variable';\nimport destructureVariableExpression from './destructure-variable';\nimport { unexpectedAssignmentOperator, unexpectedType } from './errors';\n\ntype VariableLabelExpression = (\n  state: State,\n  path: NodePath<t.VariableDeclarator>,\n  leftExpr: t.LVal,\n  rightExpr: t.Expression | null | undefined,\n) => void;\n\nfunction createVariableLabel(variableExpression: VariableLabelExpression) {\n  return (\n    state: State,\n    path: NodePath<t.LabeledStatement>,\n  ) => {\n    const { body } = path.node;\n    if (t.isExpressionStatement(body)) {\n      if (t.isAssignmentExpression(body.expression)) {\n        if (body.expression.operator !== '=') {\n          throw unexpectedAssignmentOperator(path, body.expression.operator, '=');\n        }\n        const leftExpr = body.expression.left;\n        const rightExpr = body.expression.right;\n        if (!t.isIdentifier(leftExpr)) {\n          throw unexpectedType(path, leftExpr.type, 'Identifier');\n        }\n\n        path.replaceWith(\n          t.variableDeclaration(\n            'const',\n            [\n              t.variableDeclarator(\n                leftExpr,\n                rightExpr,\n              ),\n            ],\n          ),\n        );\n      } else if (t.isIdentifier(body.expression)) {\n        path.replaceWith(\n          t.variableDeclaration(\n            'const',\n            [\n              t.variableDeclarator(\n                body.expression,\n              ),\n            ],\n          ),\n        );\n      } else if (t.isSequenceExpression(body.expression)) {\n        const exprs: t.VariableDeclarator[] = [];\n        for (let i = 0, len = body.expression.expressions.length; i < len; i += 1) {\n          const expr = body.expression.expressions[i];\n\n          if (t.isIdentifier(expr)) {\n            exprs.push(\n              t.variableDeclarator(\n                expr,\n              ),\n            );\n          } else if (t.isAssignmentExpression(expr)) {\n            if (expr.operator !== '=') {\n              throw new Error('Invalid assignment expression operator');\n            }\n            const leftExpr = expr.left;\n            const rightExpr = expr.right;\n            if (!t.isIdentifier(leftExpr)) {\n              throw unexpectedType(path, leftExpr.type, 'Identifier');\n            }\n            path.replaceWith(\n              t.variableDeclarator(\n                leftExpr,\n                rightExpr,\n              ),\n            );\n          } else {\n            throw unexpectedType(path, expr.type, 'Identifier | AssignmentExpression');\n          }\n        }\n\n        path.replaceWith(\n          t.variableDeclaration(\n            'const',\n            exprs,\n          ),\n        );\n      }\n    }\n    if (t.isVariableDeclaration(body)) {\n      body.kind = 'const';\n      path.replaceWith(\n        body,\n      );\n    }\n    if (t.isVariableDeclaration(path.node)) {\n      path.traverse({\n        VariableDeclarator(p) {\n          if (p.parentPath === path) {\n            const leftExpr = p.node.id;\n            const rightExpr = p.node.init;\n            variableExpression(state, p, leftExpr, rightExpr);\n          }\n        },\n      });\n    } else {\n      throw unexpectedType(path, path.node.type, 'VariableDeclaration');\n    }\n  };\n}\n\nfunction reactiveExpression(\n  state: State,\n  path: NodePath<t.LabeledStatement>,\n): void {\n  const { body } = path.node;\n  if (t.isExpressionStatement(body)) {\n    path.replaceWith(\n      t.callExpression(\n        getHookIdentifier(state.hooks, path, 'createEffect'),\n        [\n          t.arrowFunctionExpression(\n            [],\n            body.expression,\n          ),\n        ],\n      ),\n    );\n  } else if (t.isBlockStatement(body)) {\n    path.replaceWith(\n      t.callExpression(\n        getHookIdentifier(state.hooks, path, 'createEffect'),\n        [\n          t.arrowFunctionExpression(\n            [],\n            body,\n          ),\n        ],\n      ),\n    );\n  } else if (t.isVariableDeclaration(body)) {\n    body.kind = 'const';\n    path.replaceWith(body);\n    path.traverse({\n      VariableDeclarator(p) {\n        const leftExpr = p.node.id;\n        const rightExpr = p.node.init;\n        if (t.isIdentifier(leftExpr)) {\n          memoVariableExpression(state, p, leftExpr, rightExpr ?? t.identifier('undefined'));\n        }\n      },\n    });\n  }\n}\n\nfunction createCallbackLabel(label: string, named = false) {\n  return function expr(\n    state: State,\n    path: NodePath<t.LabeledStatement>,\n  ): void {\n    let { body } = path.node;\n    let name: string | undefined;\n    let callback: t.Expression;\n    if (named && t.isLabeledStatement(body)) {\n      name = body.label.name;\n      body = body.body;\n    }\n    if (t.isBlockStatement(body)) {\n      callback = t.arrowFunctionExpression(\n        [],\n        body,\n      );\n    } else if (t.isExpressionStatement(body)) {\n      callback = body.expression;\n    } else {\n      throw unexpectedType(path, body.type, 'BlockStatement | ExpressionStatement');\n    }\n    if (name) {\n      path.replaceWith(\n        t.callExpression(\n          getHookIdentifier(state.hooks, path, label),\n          [\n            callback,\n            t.identifier('undefined'),\n            t.objectExpression([\n              t.objectProperty(\n                t.identifier('name'),\n                t.stringLiteral(name),\n              ),\n            ]),\n          ],\n        ),\n      );\n    } else {\n      path.replaceWith(\n        t.callExpression(\n          getHookIdentifier(state.hooks, path, label),\n          [\n            callback,\n          ],\n        ),\n      );\n    }\n  };\n}\n\ntype LabelExpression = (\n  state: State,\n  path: NodePath<t.LabeledStatement>,\n) => void;\n\nconst EXPRESSIONS: Record<string, LabelExpression> = {\n  $: reactiveExpression,\n  signal: createVariableLabel((state, path, leftExpr, rightExpr) => {\n    if (t.isIdentifier(leftExpr)) {\n      signalVariableExpression(state, path, leftExpr, rightExpr ?? t.identifier('undefined'));\n    }\n  }),\n  memo: createVariableLabel((state, path, leftExpr, rightExpr) => {\n    if (t.isIdentifier(leftExpr)) {\n      memoVariableExpression(state, path, leftExpr, rightExpr ?? t.identifier('undefined'));\n    }\n  }),\n  deferred: createVariableLabel((state, path, leftExpr, rightExpr) => {\n    if (t.isIdentifier(leftExpr)) {\n      deferredVariableExpression(state, path, leftExpr, rightExpr ?? t.identifier('undefined'));\n    }\n  }),\n  destructure: createVariableLabel((state, path, leftExpr, rightExpr) => {\n    if ((t.isObjectPattern(leftExpr) || t.isArrayPattern(leftExpr)) && rightExpr) {\n      destructureVariableExpression(\n        state,\n        path,\n        rightExpr,\n        leftExpr,\n      );\n    }\n  }),\n  children: createVariableLabel((state, path, leftExpr, rightExpr) => {\n    if (t.isIdentifier(leftExpr)) {\n      accessorVariableExpression(\n        state,\n        path,\n        leftExpr,\n        'children',\n        [\n          t.arrowFunctionExpression(\n            [],\n            rightExpr ?? t.identifier('undefined'),\n          ),\n        ],\n      );\n    }\n  }),\n  effect: createCallbackLabel('createEffect', true),\n  computed: createCallbackLabel('createComputed', true),\n  renderEffect: createCallbackLabel('createRenderEffect', true),\n  mount: createCallbackLabel('onMount'),\n  cleanup: createCallbackLabel('onCleanup'),\n  error: createCallbackLabel('onError'),\n  root: createCallbackLabel('createRoot'),\n  untrack: createCallbackLabel('untrack'),\n  batch: createCallbackLabel('batch'),\n  transition: createCallbackLabel('startTransition'),\n};\n\nconst LABEL_PARSER: Visitor<State> = {\n  LabeledStatement(path, state) {\n    if (path.node.label.name in EXPRESSIONS) {\n      EXPRESSIONS[path.node.label.name](state, path);\n    }\n  },\n};\n\nexport default LABEL_PARSER;\n", "import { addNamed } from '@babel/helper-module-imports';\nimport { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { ImportHook } from './types';\n\nexport default function getHookIdentifier(\n  hooks: ImportHook,\n  path: NodePath,\n  name: string,\n  source = 'solid-js',\n): t.Identifier {\n  const current = hooks.get(name);\n  if (current) {\n    return current;\n  }\n  const newID = addNamed(path, name, source);\n  hooks.set(name, newID);\n  return newID;\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport accessorVariableExpression from './accessor-variable';\nimport normalizeAccessor from './normalize-accessor';\nimport { State } from './types';\n\nexport default function memoVariableExpression(\n  state: State,\n  path: NodePath<t.VariableDeclarator>,\n  memoIdentifier: t.Identifier,\n  stateIdentifier: t.Expression,\n  optionsIdentifier?: t.Expression,\n): void {\n  const normalIdentifier = normalizeAccessor(stateIdentifier);\n\n  if (state.opts.dev) {\n    if (optionsIdentifier) {\n      accessorVariableExpression(\n        state,\n        path,\n        memoIdentifier,\n        'createMemo',\n        [\n          normalIdentifier,\n          t.identifier('undefined'),\n          t.callExpression(\n            t.memberExpression(\n              t.identifier('Object'),\n              t.identifier('assign'),\n            ),\n            [\n              t.objectExpression([\n                t.objectProperty(\n                  t.identifier('name'),\n                  t.stringLiteral(memoIdentifier.name),\n                ),\n              ]),\n              optionsIdentifier,\n            ],\n          ),\n        ],\n      );\n    } else {\n      accessorVariableExpression(\n        state,\n        path,\n        memoIdentifier,\n        'createMemo',\n        [\n          normalIdentifier,\n          t.identifier('undefined'),\n          t.objectExpression([\n            t.objectProperty(\n              t.identifier('name'),\n              t.stringLiteral(memoIdentifier.name),\n            ),\n          ]),\n        ],\n      );\n    }\n  } else if (optionsIdentifier) {\n    accessorVariableExpression(\n      state,\n      path,\n      memoIdentifier,\n      'createMemo',\n      [\n        normalIdentifier,\n        t.identifier('undefined'),\n        optionsIdentifier,\n      ],\n    );\n  } else {\n    accessorVariableExpression(\n      state,\n      path,\n      memoIdentifier,\n      'createMemo',\n      [\n        normalIdentifier,\n      ],\n    );\n  }\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport derefMemoExpression from './deref-memo-expression';\nimport getHookIdentifier from './get-hook-identifier';\nimport { State } from './types';\n\nexport default function accessorVariableExpression(\n  state: State,\n  path: NodePath<t.VariableDeclarator>,\n  accessorIdentifier: t.Identifier,\n  mod: string,\n  replacement: Array<t.Expression | t.SpreadElement | t.JSXNamespacedName | t.ArgumentPlaceholder>,\n): void {\n  const readIdentifier = path.scope.generateUidIdentifier(accessorIdentifier.name);\n\n  path.node.id = readIdentifier;\n  path.node.init = t.callExpression(\n    getHookIdentifier(state.hooks, path, mod),\n    replacement,\n  );\n\n  derefMemoExpression(\n    path,\n    accessorIdentifier,\n    readIdentifier,\n  );\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { unexpectedMissingParent, unexpectedType } from './errors';\nimport normalizeBindings from './normalize-bindings';\n\nexport default function derefMemoExpression(\n  path: NodePath,\n  memoIdentifier: t.Identifier,\n  readIdentifier: t.Identifier,\n): void {\n  const parent = path.scope.path;\n  if (parent) {\n    parent.traverse({\n      CallExpression(p) {\n        if (p.scope !== path.scope && p.scope.hasOwnBinding(memoIdentifier.name)) {\n          return;\n        }\n        if (!t.isIdentifier(p.node.callee)) {\n          return;\n        }\n        switch (p.node.callee.name) {\n          case '$refMemo':\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === memoIdentifier.name) {\n              p.replaceWith(\n                readIdentifier,\n              );\n            }\n            break;\n          case '$get':\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === memoIdentifier.name) {\n              p.replaceWith(\n                readIdentifier,\n              );\n            }\n            break;\n          case '$getter':\n          case '$property':\n            if (!p.parentPath) {\n              throw unexpectedMissingParent(p);\n            }\n            if (!t.isObjectProperty(p.parent)) {\n              throw unexpectedType(p, p.parent.type, 'ObjectProperty');\n            }\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === memoIdentifier.name) {\n              p.parentPath.replaceWith(\n                t.objectMethod(\n                  'get',\n                  p.parent.key,\n                  [],\n                  t.blockStatement([\n                    t.returnStatement(\n                      t.callExpression(\n                        readIdentifier,\n                        [],\n                      ),\n                    ),\n                  ]),\n                ),\n              );\n            }\n            break;\n          default:\n            break;\n        }\n      },\n      ...normalizeBindings(\n        path,\n        t.callExpression(\n          readIdentifier,\n          [],\n        ),\n        memoIdentifier,\n      ),\n    });\n  }\n}\n", "import { NodePath } from '@babel/traverse';\n\nexport function unexpectedType<T>(\n  path: NodePath<T>,\n  received: string,\n  expected: string,\n): Error {\n  return path.buildCodeFrameError(`Unexpected '${received}' (Expected: ${expected})`);\n}\n\nexport function unexpectedMissingParent<T>(\n  path: NodePath<T>,\n): Error {\n  return path.buildCodeFrameError('Unexpected missing parent.');\n}\n\nexport function unexpectedArgumentLength<T>(\n  path: NodePath<T>,\n  received: number,\n  expected: number,\n): Error {\n  return path.buildCodeFrameError(`Unexpected argument length of ${received} (Expected: ${expected})`);\n}\n\nexport function unexpectedAssignmentOperator<T>(\n  path: NodePath<T>,\n  received: string,\n  expected: string,\n): Error {\n  return path.buildCodeFrameError(`Unexpected assignment operator '${received}' (Expected: ${expected})`);\n}\n", "import { NodePath, Visitor } from '@babel/traverse';\nimport * as t from '@babel/types';\n\nexport default function normalizeBindings(\n  path: NodePath,\n  replacement: t.Expression,\n  targetIdentifier: t.Identifier,\n): Visitor {\n  return {\n    ObjectProperty(p) {\n      if (\n        !(p.scope !== path.scope && p.scope.hasOwnBinding(targetIdentifier.name))\n        && p.node.shorthand\n        && t.isIdentifier(p.node.key)\n        && p.node.key.name === targetIdentifier.name\n        && t.isIdentifier(p.node.value)\n        && p.node.value.name === targetIdentifier.name\n      ) {\n        p.replaceWith(\n          t.objectProperty(\n            targetIdentifier,\n            replacement,\n          ),\n        );\n      }\n    },\n    Expression(p) {\n      if (\n        t.isIdentifier(p.node)\n        && p.node.name === targetIdentifier.name\n        && !(p.scope !== path.scope && p.scope.hasOwnBinding(targetIdentifier.name))\n      ) {\n        p.replaceWith(\n          replacement,\n        );\n      }\n    },\n  };\n}\n", "import * as t from '@babel/types';\n\nexport default function normalizeAccessor(\n  identifier: t.Expression,\n): t.Expression {\n  return (\n    t.isCallExpression(identifier)\n    && identifier.arguments.length === 0\n    && t.isExpression(identifier.callee)\n      ? identifier.callee\n      : t.arrowFunctionExpression(\n        [],\n        identifier,\n      )\n  );\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport derefSignalExpression from './deref-signal-expression';\nimport getHookIdentifier from './get-hook-identifier';\nimport { State } from './types';\n\nexport default function signalVariableExpression(\n  state: State,\n  path: NodePath<t.VariableDeclarator>,\n  signalIdentifier: t.Identifier,\n  stateIdentifier: t.Expression = t.identifier('undefined'),\n  optionsIdentifier?: t.Expression,\n): void {\n  const readIdentifier = path.scope.generateUidIdentifier(signalIdentifier.name);\n  const writeIdentifier = path.scope.generateUidIdentifier(`set${signalIdentifier.name}`);\n\n  path.node.id = t.arrayPattern([\n    readIdentifier,\n    writeIdentifier,\n  ]);\n  if (state.opts.dev) {\n    if (optionsIdentifier) {\n      path.node.init = t.callExpression(\n        getHookIdentifier(state.hooks, path, 'createSignal'),\n        [\n          stateIdentifier,\n          t.callExpression(\n            t.memberExpression(\n              t.identifier('Object'),\n              t.identifier('assign'),\n            ),\n            [\n              t.objectExpression([\n                t.objectProperty(\n                  t.identifier('name'),\n                  t.stringLiteral(signalIdentifier.name),\n                ),\n              ]),\n              optionsIdentifier,\n            ],\n          ),\n        ],\n      );\n    } else {\n      path.node.init = t.callExpression(\n        getHookIdentifier(state.hooks, path, 'createSignal'),\n        [\n          stateIdentifier,\n          t.objectExpression([\n            t.objectProperty(\n              t.identifier('name'),\n              t.stringLiteral(signalIdentifier.name),\n            ),\n          ]),\n        ],\n      );\n    }\n  } else if (optionsIdentifier) {\n    path.node.init = t.callExpression(\n      getHookIdentifier(state.hooks, path, 'createSignal'),\n      [\n        stateIdentifier,\n        optionsIdentifier,\n      ],\n    );\n  } else {\n    path.node.init = t.callExpression(\n      getHookIdentifier(state.hooks, path, 'createSignal'),\n      [\n        stateIdentifier,\n      ],\n    );\n  }\n\n  derefSignalExpression(\n    path,\n    signalIdentifier,\n    readIdentifier,\n    writeIdentifier,\n  );\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { unexpectedMissingParent, unexpectedType } from './errors';\nimport normalizeBindings from './normalize-bindings';\n\nexport default function derefSignalExpression(\n  path: NodePath,\n  signalIdentifier: t.Identifier,\n  readIdentifier: t.Identifier,\n  writeIdentifier: t.Identifier,\n): void {\n  const parent = path.scope.path;\n  if (parent) {\n    parent.traverse({\n      CallExpression(p) {\n        if (p.scope !== path.scope && p.scope.hasOwnBinding(signalIdentifier.name)) {\n          return;\n        }\n        if (!t.isIdentifier(p.node.callee)) {\n          return;\n        }\n        switch (p.node.callee.name) {\n          case '$refSignal':\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === signalIdentifier.name) {\n              p.replaceWith(\n                t.arrayExpression([\n                  readIdentifier,\n                  writeIdentifier,\n                ]),\n              );\n            }\n            break;\n          case '$get':\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === signalIdentifier.name) {\n              p.replaceWith(\n                readIdentifier,\n              );\n            }\n            break;\n          case '$set':\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === signalIdentifier.name) {\n              p.replaceWith(\n                writeIdentifier,\n              );\n            }\n            break;\n          case '$getter':\n            if (!p.parentPath) {\n              throw unexpectedMissingParent(p);\n            }\n            if (!t.isObjectProperty(p.parent)) {\n              throw unexpectedType(p, p.parent.type, 'ObjectProperty');\n            }\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            if (p.node.arguments[0].name === signalIdentifier.name) {\n              p.parentPath.replaceWith(\n                t.objectMethod(\n                  'get',\n                  p.parent.key,\n                  [],\n                  t.blockStatement([\n                    t.returnStatement(\n                      t.callExpression(\n                        readIdentifier,\n                        [],\n                      ),\n                    ),\n                  ]),\n                ),\n              );\n            }\n            break;\n          case '$setter': {\n            if (!p.parentPath) {\n              throw unexpectedMissingParent(p);\n            }\n            if (!t.isObjectProperty(p.parent)) {\n              throw unexpectedType(p, p.parent.type, 'ObjectProperty');\n            }\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            const param = p.scope.generateUidIdentifier('value');\n            if (p.node.arguments[0].name === signalIdentifier.name) {\n              p.parentPath.replaceWith(\n                t.objectMethod(\n                  'set',\n                  p.parent.key,\n                  [param],\n                  t.blockStatement([\n                    t.returnStatement(\n                      t.callExpression(\n                        writeIdentifier,\n                        [\n                          t.arrowFunctionExpression(\n                            [],\n                            param,\n                          ),\n                        ],\n                      ),\n                    ),\n                  ]),\n                ),\n              );\n            }\n          }\n            break;\n          case '$property': {\n            if (!p.parentPath) {\n              throw unexpectedMissingParent(p);\n            }\n            if (!t.isObjectProperty(p.parent)) {\n              throw unexpectedType(p, p.parent.type, 'ObjectProperty');\n            }\n            if (!t.isIdentifier(p.node.arguments[0])) {\n              throw unexpectedType(p, p.node.arguments[0].type, 'Identifier');\n            }\n            const param = p.scope.generateUidIdentifier('value');\n            if (p.node.arguments[0].name === signalIdentifier.name) {\n              p.parentPath.replaceWith(\n                t.objectMethod(\n                  'get',\n                  p.parent.key,\n                  [],\n                  t.blockStatement([\n                    t.returnStatement(\n                      t.callExpression(\n                        readIdentifier,\n                        [],\n                      ),\n                    ),\n                  ]),\n                ),\n              );\n              p.parentPath.insertAfter(\n                t.objectMethod(\n                  'set',\n                  p.parent.key,\n                  [param],\n                  t.blockStatement([\n                    t.returnStatement(\n                      t.callExpression(\n                        writeIdentifier,\n                        [\n                          t.arrowFunctionExpression(\n                            [],\n                            param,\n                          ),\n                        ],\n                      ),\n                    ),\n                  ]),\n                ),\n              );\n            }\n          }\n            break;\n          default:\n            break;\n        }\n      },\n      ...normalizeBindings(\n        path,\n        t.callExpression(\n          readIdentifier,\n          [],\n        ),\n        signalIdentifier,\n      ),\n      UpdateExpression(p) {\n        if (p.scope !== path.scope && p.scope.hasOwnBinding(signalIdentifier.name)) {\n          return;\n        }\n        if (t.isIdentifier(p.node.argument) && p.node.argument.name === signalIdentifier.name) {\n          const param = p.scope.generateUidIdentifier('current');\n          if (p.node.prefix) {\n            p.replaceWith(\n              t.callExpression(\n                writeIdentifier,\n                [\n                  t.arrowFunctionExpression(\n                    [param],\n                    t.binaryExpression(\n                      p.node.operator === '++' ? '+' : '-',\n                      param,\n                      t.numericLiteral(1),\n                    ),\n                  ),\n                ],\n              ),\n            );\n          } else {\n            p.replaceWith(\n              t.callExpression(\n                t.arrowFunctionExpression(\n                  [],\n                  t.blockStatement([\n                    t.variableDeclaration(\n                      'const',\n                      [\n                        t.variableDeclarator(\n                          param,\n                          t.callExpression(\n                            readIdentifier,\n                            [],\n                          ),\n                        ),\n                      ],\n                    ),\n                    t.expressionStatement(\n                      t.callExpression(\n                        writeIdentifier,\n                        [\n                          t.arrowFunctionExpression(\n                            [],\n                            t.binaryExpression(\n                              p.node.operator === '++' ? '+' : '-',\n                              param,\n                              t.numericLiteral(1),\n                            ),\n                          ),\n                        ],\n                      ),\n                    ),\n                    t.returnStatement(\n                      param,\n                    ),\n                  ]),\n                ),\n                [],\n              ),\n            );\n          }\n        }\n      },\n      AssignmentExpression(p) {\n        if (p.scope !== path.scope && p.scope.hasOwnBinding(signalIdentifier.name)) {\n          return;\n        }\n        const identifier = p.node.left;\n        const expression = p.node.right;\n        if (\n          t.isIdentifier(identifier)\n          && identifier.name === signalIdentifier.name\n        ) {\n          if (p.node.operator === '=') {\n            p.replaceWith(\n              t.callExpression(\n                writeIdentifier,\n                [\n                  t.arrowFunctionExpression(\n                    [],\n                    expression,\n                  ),\n                ],\n              ),\n            );\n          } else {\n            const param = p.scope.generateUidIdentifier('current');\n            p.replaceWith(\n              t.callExpression(\n                writeIdentifier,\n                [\n                  t.arrowFunctionExpression(\n                    [param],\n                    t.assignmentExpression(\n                      p.node.operator,\n                      param,\n                      expression,\n                    ),\n                  ),\n                ],\n              ),\n            );\n          }\n        }\n      },\n    });\n  }\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport accessorVariableExpression from './accessor-variable';\nimport normalizeAccessor from './normalize-accessor';\nimport { State } from './types';\n\nexport default function deferredVariableExpression(\n  state: State,\n  path: NodePath<t.VariableDeclarator>,\n  deferredIdentifier: t.Identifier,\n  stateIdentifier: t.Expression = t.identifier('undefined'),\n  optionsIdentifier?: t.Expression,\n): void {\n  const normalIdentifier = normalizeAccessor(stateIdentifier);\n  if (state.opts.dev) {\n    if (optionsIdentifier) {\n      accessorVariableExpression(\n        state,\n        path,\n        deferredIdentifier,\n        'createDeferred',\n        [\n          normalIdentifier,\n          t.callExpression(\n            t.memberExpression(\n              t.identifier('Object'),\n              t.identifier('assign'),\n            ),\n            [\n              t.objectExpression([\n                t.objectProperty(\n                  t.identifier('name'),\n                  t.stringLiteral(deferredIdentifier.name),\n                ),\n              ]),\n              optionsIdentifier,\n            ],\n          ),\n        ],\n      );\n    } else {\n      accessorVariableExpression(\n        state,\n        path,\n        deferredIdentifier,\n        'createDeferred',\n        [\n          normalIdentifier,\n          t.objectExpression([\n            t.objectProperty(\n              t.identifier('name'),\n              t.stringLiteral(deferredIdentifier.name),\n            ),\n          ]),\n        ],\n      );\n    }\n  } else if (optionsIdentifier) {\n    accessorVariableExpression(\n      state,\n      path,\n      deferredIdentifier,\n      'createDeferred',\n      [\n        normalIdentifier,\n        optionsIdentifier,\n      ],\n    );\n  } else {\n    accessorVariableExpression(\n      state,\n      path,\n      deferredIdentifier,\n      'createDeferred',\n      [\n        normalIdentifier,\n      ],\n    );\n  }\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { unexpectedType } from './errors';\nimport getHookIdentifier from './get-hook-identifier';\nimport normalizeBindings from './normalize-bindings';\nimport { State } from './types';\n\nexport default function destructureVariableExpression(\n  state: State,\n  path: NodePath<t.VariableDeclarator>,\n  target: t.Expression,\n  pattern: t.ObjectPattern | t.ArrayPattern,\n  replace = true,\n): void {\n  const otherIdentifier = path.scope.generateUidIdentifier('other');\n\n  const properties: t.Expression[] = [];\n  let restIdentifier: t.Identifier | undefined;\n\n  if (t.isObjectPattern(pattern)) {\n    for (let i = 0, len = pattern.properties.length; i < len; i += 1) {\n      const property = pattern.properties[i];\n      if (t.isObjectProperty(property)) {\n        const { value, key } = property;\n\n        if (!property.computed) {\n          if (t.isIdentifier(key)) {\n            properties.push(t.stringLiteral(key.name));\n          }\n        } else {\n          properties.push(key);\n        }\n\n        const newIdentifier = path.scope.generateUidIdentifier('prop');\n        path.insertBefore(\n          t.variableDeclarator(\n            newIdentifier,\n            t.arrowFunctionExpression(\n              [],\n              t.memberExpression(\n                target,\n                key,\n                property.computed,\n              ),\n            ),\n          ),\n        );\n\n        if (t.isObjectPattern(value) || t.isArrayPattern(value)) {\n          destructureVariableExpression(\n            state,\n            path,\n            t.callExpression(newIdentifier, []),\n            value,\n            false,\n          );\n        } else if (t.isIdentifier(value)) {\n          path.scope.path.traverse(normalizeBindings(\n            path.scope.path,\n            t.callExpression(newIdentifier, []),\n            value,\n          ));\n        } else if (t.isAssignmentPattern(value)) {\n          // TODO\n        } else {\n          throw unexpectedType(path, value.type, 'Identifier | ObjectPattern | ArrayPattern');\n        }\n      } else if (t.isIdentifier(property.argument)) {\n        restIdentifier = property.argument;\n      }\n    }\n  } else {\n    for (let i = 0, len = pattern.elements.length; i < len; i += 1) {\n      const property = pattern.elements[i];\n      if (property) {\n        const keyExpr = t.numericLiteral(i);\n\n        const newIdentifier = path.scope.generateUidIdentifier('prop');\n        path.insertBefore(\n          t.variableDeclarator(\n            newIdentifier,\n            t.arrowFunctionExpression(\n              [],\n              t.memberExpression(\n                target,\n                keyExpr,\n                true,\n              ),\n            ),\n          ),\n        );\n\n        properties.push(keyExpr);\n\n        if (t.isIdentifier(property)) {\n          path.scope.path.traverse(normalizeBindings(\n            path.scope.path,\n            t.callExpression(newIdentifier, []),\n            property,\n          ));\n        } else if (t.isArrayPattern(property) || t.isObjectPattern(property)) {\n          destructureVariableExpression(\n            state,\n            path,\n            t.callExpression(newIdentifier, []),\n            property,\n            false,\n          );\n        } else if (t.isRestElement(property)) {\n          if (t.isIdentifier(property.argument)) {\n            restIdentifier = property.argument;\n          }\n        } else {\n          // TODO AssignmentExpresison\n        }\n      }\n    }\n  }\n\n  const expr = t.variableDeclarator(\n    otherIdentifier,\n    (\n      properties.length\n        ? (\n          t.memberExpression(\n            t.callExpression(\n              getHookIdentifier(state.hooks, path, 'splitProps'),\n              [target, t.arrayExpression(properties)],\n            ),\n            t.numericLiteral(1),\n            true,\n          )\n        )\n        : target\n    ),\n  );\n\n  if (replace) {\n    path.replaceWith(expr);\n  } else {\n    path.insertAfter(expr);\n  }\n\n  if (restIdentifier) {\n    path.scope.path.traverse(normalizeBindings(\n      path.scope.path,\n      otherIdentifier,\n      restIdentifier,\n    ));\n  }\n}\n", "import { NodePath, Visitor } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport accessorVariableExpression from './accessor-variable';\nimport deferredVariableExpression from './deferred-variable';\nimport getHookIdentifier from './get-hook-identifier';\nimport memoVariableExpression from './memo-variable';\nimport signalVariableExpression from './signal-variable';\nimport destructureVariableExpression from './destructure-variable';\nimport { State } from './types';\n\nfunction signalExpression(\n  state: State,\n  path: NodePath<t.VariableDeclaration>,\n): void {\n  path.traverse({\n    VariableDeclarator(p) {\n      if (p.parentPath === path) {\n        const leftExpr = p.node.id;\n        const rightExpr = p.node.init;\n        if (t.isIdentifier(leftExpr)) {\n          signalVariableExpression(state, p, leftExpr, rightExpr ?? undefined);\n        }\n      }\n    },\n  });\n}\n\nfunction memoExpression(\n  state: State,\n  path: NodePath<t.VariableDeclaration>,\n): void {\n  path.traverse({\n    VariableDeclarator(p) {\n      if (p.parentPath === path) {\n        const leftExpr = p.node.id;\n        const rightExpr = p.node.init;\n        if (t.isIdentifier(leftExpr)) {\n          memoVariableExpression(state, p, leftExpr, rightExpr ?? t.identifier('undefined'));\n        }\n      }\n    },\n  });\n}\n\nfunction destructureExpression(\n  state: State,\n  path: NodePath<t.VariableDeclaration>,\n): void {\n  path.traverse({\n    VariableDeclarator(p) {\n      if (p.parentPath === path) {\n        const leftExpr = p.node.id;\n        const rightExpr = p.node.init;\n        if ((t.isObjectPattern(leftExpr) || t.isArrayPattern(leftExpr)) && rightExpr) {\n          destructureVariableExpression(\n            state,\n            p,\n            rightExpr,\n            leftExpr,\n          );\n        }\n      }\n    },\n  });\n}\n\nfunction deferredExpression(\n  state: State,\n  path: NodePath<t.VariableDeclaration>,\n): void {\n  path.traverse({\n    VariableDeclarator(p) {\n      if (p.parentPath === path) {\n        const leftExpr = p.node.id;\n        const rightExpr = p.node.init;\n        if (t.isIdentifier(leftExpr)) {\n          deferredVariableExpression(state, p, leftExpr, rightExpr ?? t.identifier('undefined'));\n        }\n      }\n    },\n  });\n}\n\nfunction childrenExpression(\n  state: State,\n  path: NodePath<t.VariableDeclaration>,\n): void {\n  path.traverse({\n    VariableDeclarator(p) {\n      if (p.parentPath === path) {\n        const leftExpr = p.node.id;\n        const rightExpr = p.node.init;\n        if (t.isIdentifier(leftExpr)) {\n          accessorVariableExpression(\n            state,\n            p,\n            leftExpr,\n            'children',\n            [\n              t.arrowFunctionExpression(\n                [],\n                rightExpr ?? t.identifier('undefined'),\n              ),\n            ],\n          );\n        }\n      }\n    },\n  });\n}\n\nfunction createCallbackLabel(label: string, named = false) {\n  return function expr(\n    state: State,\n    path: NodePath<t.BlockStatement | t.ExpressionStatement>,\n    name?: string,\n  ): void {\n    const body = path.node;\n    let callback: t.Expression;\n    if (t.isBlockStatement(body)) {\n      callback = t.arrowFunctionExpression(\n        [],\n        body,\n      );\n    } else {\n      callback = body.expression;\n    }\n    if (named && name) {\n      path.replaceWith(\n        t.callExpression(\n          getHookIdentifier(state.hooks, path, label),\n          [\n            callback,\n            t.identifier('undefined'),\n            t.objectExpression([\n              t.objectProperty(\n                t.identifier('name'),\n                t.stringLiteral(name),\n              ),\n            ]),\n          ],\n        ),\n      );\n    } else {\n      path.replaceWith(\n        t.callExpression(\n          getHookIdentifier(state.hooks, path, label),\n          [\n            callback,\n          ],\n        ),\n      );\n    }\n  };\n}\n\ntype CallbackLabelExpresion = (\n  state: State,\n  path: NodePath<t.BlockStatement | t.ExpressionStatement>,\n  name: string | undefined,\n) => void;\n\ntype StateExpression = (\n  state: State,\n  path: NodePath<t.VariableDeclaration>,\n) => void;\n\nconst STATE_EXPRESSIONS: Record<string, StateExpression> = {\n  '@signal': signalExpression,\n  '@memo': memoExpression,\n  '@children': childrenExpression,\n  '@deferred': deferredExpression,\n  '@destructure': destructureExpression,\n};\n\nconst CALLBACK_EXPRESSIONS: Record<string, CallbackLabelExpresion> = {\n  '@effect': createCallbackLabel('createEffect', true),\n  '@computed': createCallbackLabel('createComputed', true),\n  '@renderEffect': createCallbackLabel('createRenderEffect', true),\n  '@mount': createCallbackLabel('onMount'),\n  '@cleanup': createCallbackLabel('onCleanup'),\n  '@error': createCallbackLabel('onError'),\n  '@root': createCallbackLabel('createRoot'),\n  '@untrack': createCallbackLabel('untrack'),\n  '@batch': createCallbackLabel('batch'),\n  '@transition': createCallbackLabel('startTransition'),\n};\n\nconst COMMENT_PARSER: Visitor<State> = {\n  VariableDeclaration(path, state) {\n    const comments = path.node.leadingComments;\n    if (comments) {\n      let preference: string | undefined;\n      for (let i = 0, len = comments.length; i < len; i += 1) {\n        const comment: t.Comment = comments[i];\n        const value: string = comment.value.trim();\n        if (value in STATE_EXPRESSIONS) {\n          preference = value;\n          comment.value = '';\n        }\n      }\n      if (preference) {\n        STATE_EXPRESSIONS[preference](state, path);\n      }\n    }\n  },\n  BlockStatement(path, state) {\n    if (\n      t.isFunctionDeclaration(path.parent)\n    ) {\n      return;\n    }\n    const comments = path.node.leadingComments;\n    if (comments) {\n      let preference: string | undefined;\n      let name: string | undefined;\n      for (let i = 0, len = comments.length; i < len; i += 1) {\n        const comment: t.Comment = comments[i];\n        const value: string = comment.value.trim();\n        if (/^@\\w+( .*)?$/.test(value)) {\n          const [tag, ...debugName] = value.split(' ');\n          if (tag in CALLBACK_EXPRESSIONS) {\n            preference = tag;\n            name = debugName.join(' ');\n            comment.value = '';\n          }\n        }\n      }\n      if (preference) {\n        CALLBACK_EXPRESSIONS[preference](state, path, name);\n      }\n    }\n  },\n  ExpressionStatement(path, state) {\n    const comments = path.node.leadingComments;\n    if (comments) {\n      let preference: string | undefined;\n      let name: string | undefined;\n      for (let i = 0, len = comments.length; i < len; i += 1) {\n        const comment: t.Comment = comments[i];\n        const value: string = comment.value.trim();\n        if (/^@\\w+( .*)?$/.test(value)) {\n          const [tag, ...debugName] = value.split(' ');\n          if (tag in CALLBACK_EXPRESSIONS) {\n            preference = tag;\n            name = debugName.join(' ');\n            comment.value = '';\n          }\n        }\n      }\n      if (preference) {\n        CALLBACK_EXPRESSIONS[preference](state, path, name);\n      }\n    }\n  },\n};\n\nexport default COMMENT_PARSER;\n", "import { NodePath, Visitor } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport getHookIdentifier from './get-hook-identifier';\nimport { State } from './types';\nimport {\n  unexpectedArgumentLength,\n  unexpectedMissingParent,\n  unexpectedType,\n} from './errors';\nimport derefSignalVariableExpression from './deref-signal-variable';\nimport derefMemoVariableExpression from './deref-memo-variable';\nimport memoVariableExpression from './memo-variable';\nimport signalVariableExpression from './signal-variable';\nimport accessorVariableExpression from './accessor-variable';\nimport deferredVariableExpression from './deferred-variable';\nimport destructureVariableExpression from './destructure-variable';\nimport normalizeAccessor from './normalize-accessor';\n\nfunction derefSignalExpression(\n  _: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 1) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!t.isIdentifier(leftExpr)) {\n    throw unexpectedType(path.parentPath, leftExpr.type, 'Identifier');\n  }\n  derefSignalVariableExpression(\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    leftExpr,\n    argument,\n  );\n}\n\nfunction signalExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 2) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 2);\n  }\n  let argument: t.Expression | undefined;\n  let options: t.Expression | undefined;\n  if (path.node.arguments.length > 0) {\n    const initialState = path.node.arguments[0];\n    if (!t.isExpression(initialState)) {\n      throw unexpectedType(path, initialState.type, 'Expression');\n    }\n    argument = initialState;\n    if (path.node.arguments.length > 1) {\n      const optionsValue = path.node.arguments[1];\n      if (!t.isExpression(optionsValue)) {\n        throw unexpectedType(path, optionsValue.type, 'Expression');\n      }\n      options = optionsValue;\n    }\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!t.isIdentifier(leftExpr)) {\n    throw unexpectedType(path.parentPath, leftExpr.type, 'Identifier');\n  }\n  signalVariableExpression(\n    state,\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    leftExpr,\n    argument,\n    options,\n  );\n}\n\nfunction derefMemoExpression(\n  _: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 1) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!t.isIdentifier(leftExpr)) {\n    throw unexpectedType(path.parentPath, leftExpr.type, 'Expression');\n  }\n  derefMemoVariableExpression(\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    leftExpr,\n    argument,\n  );\n}\n\nfunction memoExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 2) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 2);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  let options: t.Expression | undefined;\n  if (path.node.arguments.length > 1) {\n    const optionsValue = path.node.arguments[1];\n    if (!t.isExpression(optionsValue)) {\n      throw unexpectedType(path, optionsValue.type, 'Expression');\n    }\n    options = optionsValue;\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!t.isIdentifier(leftExpr)) {\n    throw unexpectedType(path.parentPath, leftExpr.type, 'Expression');\n  }\n  memoVariableExpression(\n    state,\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    leftExpr,\n    argument,\n    options,\n  );\n}\n\nfunction deferredExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 2) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 2);\n  }\n  let argument: t.Expression | undefined;\n  let options: t.Expression | undefined;\n  if (path.node.arguments.length > 0) {\n    const initialState = path.node.arguments[0];\n    if (!t.isExpression(initialState)) {\n      throw unexpectedType(path, initialState.type, 'Expression');\n    }\n    argument = initialState;\n    if (path.node.arguments.length > 1) {\n      const optionsValue = path.node.arguments[1];\n      if (!t.isExpression(optionsValue)) {\n        throw unexpectedType(path, optionsValue.type, 'Expression');\n      }\n      options = optionsValue;\n    }\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!t.isIdentifier(leftExpr)) {\n    throw unexpectedType(path, leftExpr.type, 'Identifier');\n  }\n  deferredVariableExpression(\n    state,\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    leftExpr,\n    argument,\n    options,\n  );\n}\n\nfunction reactiveExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 1) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (t.isVariableDeclarator(path.parent)) {\n    const leftExpr = path.parent.id;\n    if (!t.isIdentifier(leftExpr)) {\n      throw unexpectedType(path, leftExpr.type, 'Identifier');\n    }\n    memoVariableExpression(\n      state,\n      path.parentPath as NodePath<t.VariableDeclarator>,\n      leftExpr,\n      argument,\n    );\n  } else if (t.isExpressionStatement(path.parent)) {\n    path.replaceWith(\n      t.callExpression(\n        getHookIdentifier(state.hooks, path, 'createEffect'),\n        [\n          t.arrowFunctionExpression(\n            [],\n            argument,\n          ),\n        ],\n      ),\n    );\n  } else {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator | ExpressionStatement');\n  }\n}\n\nfunction rootExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 1) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  const arrow = (\n    (t.isArrowFunctionExpression(argument) || t.isFunctionExpression(argument))\n      ? argument\n      : (\n        t.arrowFunctionExpression(\n          [],\n          argument,\n        )\n      )\n  );\n  path.replaceWith(\n    t.callExpression(\n      getHookIdentifier(state.hooks, path, 'createRoot'),\n      [\n        arrow,\n      ],\n    ),\n  );\n}\n\nfunction fromExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 1) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!t.isIdentifier(leftExpr)) {\n    throw unexpectedType(path, leftExpr.type, 'Identifier');\n  }\n  accessorVariableExpression(\n    state,\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    leftExpr,\n    'from',\n    [\n      argument,\n    ],\n  );\n}\n\nfunction createCompileTimeAutoAccessor(target: string, limit: number) {\n  return (\n    state: State,\n    path: NodePath<t.CallExpression>,\n  ) => {\n    if (path.node.arguments.length > limit) {\n      throw unexpectedArgumentLength(path, path.node.arguments.length, limit);\n    }\n    const [argument, ...rest] = path.node.arguments;\n    if (!t.isExpression(argument)) {\n      throw unexpectedType(path, argument.type, 'Expression');\n    }\n    if (!path.parentPath) {\n      throw unexpectedMissingParent(path);\n    }\n    if (!t.isVariableDeclarator(path.parent)) {\n      throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n    }\n    const leftExpr = path.parent.id;\n    if (!t.isIdentifier(leftExpr)) {\n      throw unexpectedType(path, leftExpr.type, 'Identifier');\n    }\n    accessorVariableExpression(\n      state,\n      path.parentPath as NodePath<t.VariableDeclarator>,\n      leftExpr,\n      target,\n      [\n        normalizeAccessor(argument),\n        ...rest,\n      ],\n    );\n  };\n}\n\ntype CompileTimeFunctionExpression = (\n  state: State,\n  path: NodePath<t.CallExpression>,\n) => void;\n\nfunction createCompileTimeAlias(target: string, source?: string) {\n  return (\n    state: State,\n    path: NodePath<t.CallExpression>,\n  ) => {\n    path.node.callee = getHookIdentifier(state.hooks, path, target, source);\n  };\n}\n\nfunction createCompileTimeAutoArrow(target: string, limit: number) {\n  return (\n    state: State,\n    path: NodePath<t.CallExpression>,\n  ) => {\n    if (path.node.arguments.length > limit) {\n      throw unexpectedArgumentLength(path, path.node.arguments.length, limit);\n    }\n    const [argument, ...rest] = path.node.arguments;\n    if (!t.isExpression(argument)) {\n      throw unexpectedType(path, argument.type, 'Expression');\n    }\n    path.replaceWith(\n      t.callExpression(\n        getHookIdentifier(state.hooks, path, target),\n        [\n          normalizeAccessor(argument),\n          ...rest,\n        ],\n      ),\n    );\n  };\n}\n\nfunction destructureExpression(\n  state: State,\n  path: NodePath<t.CallExpression>,\n): void {\n  if (path.node.arguments.length > 1) {\n    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);\n  }\n  const argument = path.node.arguments[0];\n  if (!t.isExpression(argument)) {\n    throw unexpectedType(path, argument.type, 'Expression');\n  }\n  if (!path.parentPath) {\n    throw unexpectedMissingParent(path);\n  }\n  if (!t.isVariableDeclarator(path.parent)) {\n    throw unexpectedType(path.parentPath, path.parent.type, 'VariableDeclarator');\n  }\n  const leftExpr = path.parent.id;\n  if (!(t.isObjectPattern(leftExpr) || t.isArrayPattern(leftExpr))) {\n    throw unexpectedType(path, leftExpr.type, 'ArrayPattern | ObjectPattern');\n  }\n  destructureVariableExpression(\n    state,\n    path.parentPath as NodePath<t.VariableDeclarator>,\n    argument,\n    leftExpr,\n  );\n}\n\nconst CTF_EXPRESSIONS: Record<string, CompileTimeFunctionExpression> = {\n  $: reactiveExpression,\n  $derefSignal: derefSignalExpression,\n  $derefMemo: derefMemoExpression,\n  $signal: signalExpression,\n  $memo: memoExpression,\n  $root: rootExpression,\n  $from: fromExpression,\n  $deferred: deferredExpression,\n\n  // auto accessors + auto arrow\n  $children: createCompileTimeAutoAccessor('children', 1),\n  $mapArray: createCompileTimeAutoAccessor('mapArray', 3),\n  $indexArray: createCompileTimeAutoAccessor('indexArray', 3),\n\n  // auto arrows\n  $lazy: createCompileTimeAutoArrow('lazy', 1),\n  $untrack: createCompileTimeAutoArrow('untrack', 1),\n  $batch: createCompileTimeAutoArrow('batch', 1),\n  $observable: createCompileTimeAutoArrow('observable', 1),\n  $selector: createCompileTimeAutoArrow('createSelector', 1),\n  $on: createCompileTimeAutoArrow('on', 3),\n\n  // aliases\n  $useContext: createCompileTimeAlias('useContext'),\n  $createContext: createCompileTimeAlias('createContext'),\n  $uid: createCompileTimeAlias('createUniqueId'),\n  $effect: createCompileTimeAlias('createEffect'),\n  $computed: createCompileTimeAlias('createComputed'),\n  $renderEffect: createCompileTimeAlias('createRenderEffect'),\n  $merge: createCompileTimeAlias('mergeProps'),\n  $resource: createCompileTimeAlias('createResource'),\n\n  $store: createCompileTimeAlias('createStore', 'solid-js/store'),\n  $mutable: createCompileTimeAlias('createMutable', 'solid-js/store'),\n  $produce: createCompileTimeAlias('produce', 'solid-js/store'),\n  $reconcile: createCompileTimeAlias('reconcile', 'solid-js/store'),\n\n  $destructure: destructureExpression,\n};\n\nconst CTF_PARSER: Visitor<State> = {\n  CallExpression(path, state) {\n    if (\n      t.isIdentifier(path.node.callee)\n      && path.node.callee.name in CTF_EXPRESSIONS\n      && !path.scope.hasBinding(path.node.callee.name)\n    ) {\n      CTF_EXPRESSIONS[path.node.callee.name](state, path);\n    }\n  },\n};\n\nexport default CTF_PARSER;\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport derefSignalExpression from './deref-signal-expression';\n\nexport default function derefSignalVariableExpression(\n  path: NodePath<t.VariableDeclarator>,\n  signalIdentifier: t.Identifier,\n  stateIdentifier: t.Expression,\n): void {\n  const readIdentifier = path.scope.generateUidIdentifier(signalIdentifier.name);\n  const writeIdentifier = path.scope.generateUidIdentifier(`set${signalIdentifier.name}`);\n\n  path.node.id = t.arrayPattern([\n    readIdentifier,\n    writeIdentifier,\n  ]);\n  path.node.init = stateIdentifier;\n\n  derefSignalExpression(\n    path,\n    signalIdentifier,\n    readIdentifier,\n    writeIdentifier,\n  );\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport derefMemoExpression from './deref-memo-expression';\n\nexport default function derefMemoVariableExpression(\n  path: NodePath<t.VariableDeclarator>,\n  memoIdentifier: t.Identifier,\n  stateIdentifier: t.Expression,\n): void {\n  const readIdentifier = path.scope.generateUidIdentifier(memoIdentifier.name);\n\n  path.node.id = readIdentifier;\n  path.node.init = stateIdentifier;\n\n  derefMemoExpression(\n    path,\n    memoIdentifier,\n    readIdentifier,\n  );\n}\n", "import { NodePath, Visitor } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { State } from './types';\nimport getHookIdentifier from './get-hook-identifier';\n\ntype AutoImportExpression = (state: State, path: NodePath<t.Expression>) => void;\n\nfunction createAutoImport(target: string, source?: string) {\n  return (\n    state: State,\n    path: NodePath<t.Expression>,\n  ) => {\n    path.replaceWith(getHookIdentifier(state.hooks, path, target, source));\n  };\n}\n\nconst AUTO_IMPORT_EXPR: Record<string, AutoImportExpression> = {\n  $for: createAutoImport('For'),\n  $show: createAutoImport('Show'),\n  $switch: createAutoImport('Switch'),\n  $match: createAutoImport('Match'),\n  $index: createAutoImport('Index'),\n  $errorBoundary: createAutoImport('ErrorBoundary'),\n  $suspense: createAutoImport('Suspense'),\n  $suspenseList: createAutoImport('SuspenseList'),\n  $dynamic: createAutoImport('Dynamic', 'solid-js/web'),\n  $portal: createAutoImport('Portal', 'solid-js/web'),\n  $assets: createAutoImport('Assets', 'solid-js/web'),\n  $hydrationScript: createAutoImport('HydrationScript', 'solid-js/web'),\n  $noHydration: createAutoImport('NoHydration', 'solid-js/web'),\n};\n\nconst AUTO_IMPORT: Visitor<State> = {\n  Expression(p, state) {\n    if (\n      t.isIdentifier(p.node)\n      && !p.scope.hasBinding(p.node.name)\n      && p.node.name in AUTO_IMPORT_EXPR\n    ) {\n      AUTO_IMPORT_EXPR[p.node.name](state, p);\n    }\n  },\n};\n\nexport default AUTO_IMPORT;\n"],
  "mappings": "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",
  "names": []
}

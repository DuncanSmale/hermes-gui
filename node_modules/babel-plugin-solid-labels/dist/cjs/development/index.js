"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  default: () => solidReactivityPlugin
});

// src/label-parser.ts
var t10 = __toModule(require("@babel/types"));

// src/get-hook-identifier.ts
var import_helper_module_imports = __toModule(require("@babel/helper-module-imports"));
function getHookIdentifier(hooks, path, name, source = "solid-js") {
  const current = hooks.get(name);
  if (current) {
    return current;
  }
  const newID = (0, import_helper_module_imports.addNamed)(path, name, source);
  hooks.set(name, newID);
  return newID;
}

// src/memo-variable.ts
var t5 = __toModule(require("@babel/types"));

// src/accessor-variable.ts
var t3 = __toModule(require("@babel/types"));

// src/deref-memo-expression.ts
var t2 = __toModule(require("@babel/types"));

// src/errors.ts
function unexpectedType(path, received, expected) {
  return path.buildCodeFrameError(`Unexpected '${received}' (Expected: ${expected})`);
}
function unexpectedMissingParent(path) {
  return path.buildCodeFrameError("Unexpected missing parent.");
}
function unexpectedArgumentLength(path, received, expected) {
  return path.buildCodeFrameError(`Unexpected argument length of ${received} (Expected: ${expected})`);
}
function unexpectedAssignmentOperator(path, received, expected) {
  return path.buildCodeFrameError(`Unexpected assignment operator '${received}' (Expected: ${expected})`);
}

// src/normalize-bindings.ts
var t = __toModule(require("@babel/types"));
function normalizeBindings(path, replacement, targetIdentifier) {
  return {
    ObjectProperty(p) {
      if (!(p.scope !== path.scope && p.scope.hasOwnBinding(targetIdentifier.name)) && p.node.shorthand && t.isIdentifier(p.node.key) && p.node.key.name === targetIdentifier.name && t.isIdentifier(p.node.value) && p.node.value.name === targetIdentifier.name) {
        p.replaceWith(t.objectProperty(targetIdentifier, replacement));
      }
    },
    Expression(p) {
      if (t.isIdentifier(p.node) && p.node.name === targetIdentifier.name && !(p.scope !== path.scope && p.scope.hasOwnBinding(targetIdentifier.name))) {
        p.replaceWith(replacement);
      }
    }
  };
}

// src/deref-memo-expression.ts
function derefMemoExpression(path, memoIdentifier, readIdentifier) {
  const parent = path.scope.path;
  if (parent) {
    parent.traverse(__spreadValues({
      CallExpression(p) {
        if (p.scope !== path.scope && p.scope.hasOwnBinding(memoIdentifier.name)) {
          return;
        }
        if (!t2.isIdentifier(p.node.callee)) {
          return;
        }
        switch (p.node.callee.name) {
          case "$refMemo":
            if (!t2.isIdentifier(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === memoIdentifier.name) {
              p.replaceWith(readIdentifier);
            }
            break;
          case "$get":
            if (!t2.isIdentifier(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === memoIdentifier.name) {
              p.replaceWith(readIdentifier);
            }
            break;
          case "$getter":
          case "$property":
            if (!p.parentPath) {
              throw unexpectedMissingParent(p);
            }
            if (!t2.isObjectProperty(p.parent)) {
              throw unexpectedType(p, p.parent.type, "ObjectProperty");
            }
            if (!t2.isIdentifier(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === memoIdentifier.name) {
              p.parentPath.replaceWith(t2.objectMethod("get", p.parent.key, [], t2.blockStatement([
                t2.returnStatement(t2.callExpression(readIdentifier, []))
              ])));
            }
            break;
          default:
            break;
        }
      }
    }, normalizeBindings(path, t2.callExpression(readIdentifier, []), memoIdentifier)));
  }
}

// src/accessor-variable.ts
function accessorVariableExpression(state, path, accessorIdentifier, mod, replacement) {
  const readIdentifier = path.scope.generateUidIdentifier(accessorIdentifier.name);
  path.node.id = readIdentifier;
  path.node.init = t3.callExpression(getHookIdentifier(state.hooks, path, mod), replacement);
  derefMemoExpression(path, accessorIdentifier, readIdentifier);
}

// src/normalize-accessor.ts
var t4 = __toModule(require("@babel/types"));
function normalizeAccessor(identifier6) {
  return t4.isCallExpression(identifier6) && identifier6.arguments.length === 0 && t4.isExpression(identifier6.callee) ? identifier6.callee : t4.arrowFunctionExpression([], identifier6);
}

// src/memo-variable.ts
function memoVariableExpression(state, path, memoIdentifier, stateIdentifier, optionsIdentifier) {
  const normalIdentifier = normalizeAccessor(stateIdentifier);
  if (state.opts.dev) {
    if (optionsIdentifier) {
      accessorVariableExpression(state, path, memoIdentifier, "createMemo", [
        normalIdentifier,
        t5.identifier("undefined"),
        t5.callExpression(t5.memberExpression(t5.identifier("Object"), t5.identifier("assign")), [
          t5.objectExpression([
            t5.objectProperty(t5.identifier("name"), t5.stringLiteral(memoIdentifier.name))
          ]),
          optionsIdentifier
        ])
      ]);
    } else {
      accessorVariableExpression(state, path, memoIdentifier, "createMemo", [
        normalIdentifier,
        t5.identifier("undefined"),
        t5.objectExpression([
          t5.objectProperty(t5.identifier("name"), t5.stringLiteral(memoIdentifier.name))
        ])
      ]);
    }
  } else if (optionsIdentifier) {
    accessorVariableExpression(state, path, memoIdentifier, "createMemo", [
      normalIdentifier,
      t5.identifier("undefined"),
      optionsIdentifier
    ]);
  } else {
    accessorVariableExpression(state, path, memoIdentifier, "createMemo", [
      normalIdentifier
    ]);
  }
}

// src/signal-variable.ts
var t7 = __toModule(require("@babel/types"));

// src/deref-signal-expression.ts
var t6 = __toModule(require("@babel/types"));
function derefSignalExpression(path, signalIdentifier, readIdentifier, writeIdentifier) {
  const parent = path.scope.path;
  if (parent) {
    parent.traverse(__spreadProps(__spreadValues({
      CallExpression(p) {
        if (p.scope !== path.scope && p.scope.hasOwnBinding(signalIdentifier.name)) {
          return;
        }
        if (!t6.isIdentifier(p.node.callee)) {
          return;
        }
        switch (p.node.callee.name) {
          case "$refSignal":
            if (!t6.isIdentifier(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === signalIdentifier.name) {
              p.replaceWith(t6.arrayExpression([
                readIdentifier,
                writeIdentifier
              ]));
            }
            break;
          case "$get":
            if (!t6.isIdentifier(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === signalIdentifier.name) {
              p.replaceWith(readIdentifier);
            }
            break;
          case "$set":
            if (!t6.isIdentifier(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === signalIdentifier.name) {
              p.replaceWith(writeIdentifier);
            }
            break;
          case "$getter":
            if (!p.parentPath) {
              throw unexpectedMissingParent(p);
            }
            if (!t6.isObjectProperty(p.parent)) {
              throw unexpectedType(p, p.parent.type, "ObjectProperty");
            }
            if (!t6.isIdentifier(p.node.arguments[0])) {
              throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
            }
            if (p.node.arguments[0].name === signalIdentifier.name) {
              p.parentPath.replaceWith(t6.objectMethod("get", p.parent.key, [], t6.blockStatement([
                t6.returnStatement(t6.callExpression(readIdentifier, []))
              ])));
            }
            break;
          case "$setter":
            {
              if (!p.parentPath) {
                throw unexpectedMissingParent(p);
              }
              if (!t6.isObjectProperty(p.parent)) {
                throw unexpectedType(p, p.parent.type, "ObjectProperty");
              }
              if (!t6.isIdentifier(p.node.arguments[0])) {
                throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
              }
              const param = p.scope.generateUidIdentifier("value");
              if (p.node.arguments[0].name === signalIdentifier.name) {
                p.parentPath.replaceWith(t6.objectMethod("set", p.parent.key, [param], t6.blockStatement([
                  t6.returnStatement(t6.callExpression(writeIdentifier, [
                    t6.arrowFunctionExpression([], param)
                  ]))
                ])));
              }
            }
            break;
          case "$property":
            {
              if (!p.parentPath) {
                throw unexpectedMissingParent(p);
              }
              if (!t6.isObjectProperty(p.parent)) {
                throw unexpectedType(p, p.parent.type, "ObjectProperty");
              }
              if (!t6.isIdentifier(p.node.arguments[0])) {
                throw unexpectedType(p, p.node.arguments[0].type, "Identifier");
              }
              const param = p.scope.generateUidIdentifier("value");
              if (p.node.arguments[0].name === signalIdentifier.name) {
                p.parentPath.replaceWith(t6.objectMethod("get", p.parent.key, [], t6.blockStatement([
                  t6.returnStatement(t6.callExpression(readIdentifier, []))
                ])));
                p.parentPath.insertAfter(t6.objectMethod("set", p.parent.key, [param], t6.blockStatement([
                  t6.returnStatement(t6.callExpression(writeIdentifier, [
                    t6.arrowFunctionExpression([], param)
                  ]))
                ])));
              }
            }
            break;
          default:
            break;
        }
      }
    }, normalizeBindings(path, t6.callExpression(readIdentifier, []), signalIdentifier)), {
      UpdateExpression(p) {
        if (p.scope !== path.scope && p.scope.hasOwnBinding(signalIdentifier.name)) {
          return;
        }
        if (t6.isIdentifier(p.node.argument) && p.node.argument.name === signalIdentifier.name) {
          const param = p.scope.generateUidIdentifier("current");
          if (p.node.prefix) {
            p.replaceWith(t6.callExpression(writeIdentifier, [
              t6.arrowFunctionExpression([param], t6.binaryExpression(p.node.operator === "++" ? "+" : "-", param, t6.numericLiteral(1)))
            ]));
          } else {
            p.replaceWith(t6.callExpression(t6.arrowFunctionExpression([], t6.blockStatement([
              t6.variableDeclaration("const", [
                t6.variableDeclarator(param, t6.callExpression(readIdentifier, []))
              ]),
              t6.expressionStatement(t6.callExpression(writeIdentifier, [
                t6.arrowFunctionExpression([], t6.binaryExpression(p.node.operator === "++" ? "+" : "-", param, t6.numericLiteral(1)))
              ])),
              t6.returnStatement(param)
            ])), []));
          }
        }
      },
      AssignmentExpression(p) {
        if (p.scope !== path.scope && p.scope.hasOwnBinding(signalIdentifier.name)) {
          return;
        }
        const identifier6 = p.node.left;
        const expression = p.node.right;
        if (t6.isIdentifier(identifier6) && identifier6.name === signalIdentifier.name) {
          if (p.node.operator === "=") {
            p.replaceWith(t6.callExpression(writeIdentifier, [
              t6.arrowFunctionExpression([], expression)
            ]));
          } else {
            const param = p.scope.generateUidIdentifier("current");
            p.replaceWith(t6.callExpression(writeIdentifier, [
              t6.arrowFunctionExpression([param], t6.assignmentExpression(p.node.operator, param, expression))
            ]));
          }
        }
      }
    }));
  }
}

// src/signal-variable.ts
function signalVariableExpression(state, path, signalIdentifier, stateIdentifier = t7.identifier("undefined"), optionsIdentifier) {
  const readIdentifier = path.scope.generateUidIdentifier(signalIdentifier.name);
  const writeIdentifier = path.scope.generateUidIdentifier(`set${signalIdentifier.name}`);
  path.node.id = t7.arrayPattern([
    readIdentifier,
    writeIdentifier
  ]);
  if (state.opts.dev) {
    if (optionsIdentifier) {
      path.node.init = t7.callExpression(getHookIdentifier(state.hooks, path, "createSignal"), [
        stateIdentifier,
        t7.callExpression(t7.memberExpression(t7.identifier("Object"), t7.identifier("assign")), [
          t7.objectExpression([
            t7.objectProperty(t7.identifier("name"), t7.stringLiteral(signalIdentifier.name))
          ]),
          optionsIdentifier
        ])
      ]);
    } else {
      path.node.init = t7.callExpression(getHookIdentifier(state.hooks, path, "createSignal"), [
        stateIdentifier,
        t7.objectExpression([
          t7.objectProperty(t7.identifier("name"), t7.stringLiteral(signalIdentifier.name))
        ])
      ]);
    }
  } else if (optionsIdentifier) {
    path.node.init = t7.callExpression(getHookIdentifier(state.hooks, path, "createSignal"), [
      stateIdentifier,
      optionsIdentifier
    ]);
  } else {
    path.node.init = t7.callExpression(getHookIdentifier(state.hooks, path, "createSignal"), [
      stateIdentifier
    ]);
  }
  derefSignalExpression(path, signalIdentifier, readIdentifier, writeIdentifier);
}

// src/deferred-variable.ts
var t8 = __toModule(require("@babel/types"));
function deferredVariableExpression(state, path, deferredIdentifier, stateIdentifier = t8.identifier("undefined"), optionsIdentifier) {
  const normalIdentifier = normalizeAccessor(stateIdentifier);
  if (state.opts.dev) {
    if (optionsIdentifier) {
      accessorVariableExpression(state, path, deferredIdentifier, "createDeferred", [
        normalIdentifier,
        t8.callExpression(t8.memberExpression(t8.identifier("Object"), t8.identifier("assign")), [
          t8.objectExpression([
            t8.objectProperty(t8.identifier("name"), t8.stringLiteral(deferredIdentifier.name))
          ]),
          optionsIdentifier
        ])
      ]);
    } else {
      accessorVariableExpression(state, path, deferredIdentifier, "createDeferred", [
        normalIdentifier,
        t8.objectExpression([
          t8.objectProperty(t8.identifier("name"), t8.stringLiteral(deferredIdentifier.name))
        ])
      ]);
    }
  } else if (optionsIdentifier) {
    accessorVariableExpression(state, path, deferredIdentifier, "createDeferred", [
      normalIdentifier,
      optionsIdentifier
    ]);
  } else {
    accessorVariableExpression(state, path, deferredIdentifier, "createDeferred", [
      normalIdentifier
    ]);
  }
}

// src/destructure-variable.ts
var t9 = __toModule(require("@babel/types"));
function destructureVariableExpression(state, path, target, pattern, replace = true) {
  const otherIdentifier = path.scope.generateUidIdentifier("other");
  const properties = [];
  let restIdentifier;
  if (t9.isObjectPattern(pattern)) {
    for (let i = 0, len = pattern.properties.length; i < len; i += 1) {
      const property = pattern.properties[i];
      if (t9.isObjectProperty(property)) {
        const { value, key } = property;
        if (!property.computed) {
          if (t9.isIdentifier(key)) {
            properties.push(t9.stringLiteral(key.name));
          }
        } else {
          properties.push(key);
        }
        const newIdentifier = path.scope.generateUidIdentifier("prop");
        path.insertBefore(t9.variableDeclarator(newIdentifier, t9.arrowFunctionExpression([], t9.memberExpression(target, key, property.computed))));
        if (t9.isObjectPattern(value) || t9.isArrayPattern(value)) {
          destructureVariableExpression(state, path, t9.callExpression(newIdentifier, []), value, false);
        } else if (t9.isIdentifier(value)) {
          path.scope.path.traverse(normalizeBindings(path.scope.path, t9.callExpression(newIdentifier, []), value));
        } else if (t9.isAssignmentPattern(value)) {
        } else {
          throw unexpectedType(path, value.type, "Identifier | ObjectPattern | ArrayPattern");
        }
      } else if (t9.isIdentifier(property.argument)) {
        restIdentifier = property.argument;
      }
    }
  } else {
    for (let i = 0, len = pattern.elements.length; i < len; i += 1) {
      const property = pattern.elements[i];
      if (property) {
        const keyExpr = t9.numericLiteral(i);
        const newIdentifier = path.scope.generateUidIdentifier("prop");
        path.insertBefore(t9.variableDeclarator(newIdentifier, t9.arrowFunctionExpression([], t9.memberExpression(target, keyExpr, true))));
        properties.push(keyExpr);
        if (t9.isIdentifier(property)) {
          path.scope.path.traverse(normalizeBindings(path.scope.path, t9.callExpression(newIdentifier, []), property));
        } else if (t9.isArrayPattern(property) || t9.isObjectPattern(property)) {
          destructureVariableExpression(state, path, t9.callExpression(newIdentifier, []), property, false);
        } else if (t9.isRestElement(property)) {
          if (t9.isIdentifier(property.argument)) {
            restIdentifier = property.argument;
          }
        } else {
        }
      }
    }
  }
  const expr = t9.variableDeclarator(otherIdentifier, properties.length ? t9.memberExpression(t9.callExpression(getHookIdentifier(state.hooks, path, "splitProps"), [target, t9.arrayExpression(properties)]), t9.numericLiteral(1), true) : target);
  if (replace) {
    path.replaceWith(expr);
  } else {
    path.insertAfter(expr);
  }
  if (restIdentifier) {
    path.scope.path.traverse(normalizeBindings(path.scope.path, otherIdentifier, restIdentifier));
  }
}

// src/label-parser.ts
function createVariableLabel(variableExpression) {
  return (state, path) => {
    const { body } = path.node;
    if (t10.isExpressionStatement(body)) {
      if (t10.isAssignmentExpression(body.expression)) {
        if (body.expression.operator !== "=") {
          throw unexpectedAssignmentOperator(path, body.expression.operator, "=");
        }
        const leftExpr = body.expression.left;
        const rightExpr = body.expression.right;
        if (!t10.isIdentifier(leftExpr)) {
          throw unexpectedType(path, leftExpr.type, "Identifier");
        }
        path.replaceWith(t10.variableDeclaration("const", [
          t10.variableDeclarator(leftExpr, rightExpr)
        ]));
      } else if (t10.isIdentifier(body.expression)) {
        path.replaceWith(t10.variableDeclaration("const", [
          t10.variableDeclarator(body.expression)
        ]));
      } else if (t10.isSequenceExpression(body.expression)) {
        const exprs = [];
        for (let i = 0, len = body.expression.expressions.length; i < len; i += 1) {
          const expr = body.expression.expressions[i];
          if (t10.isIdentifier(expr)) {
            exprs.push(t10.variableDeclarator(expr));
          } else if (t10.isAssignmentExpression(expr)) {
            if (expr.operator !== "=") {
              throw new Error("Invalid assignment expression operator");
            }
            const leftExpr = expr.left;
            const rightExpr = expr.right;
            if (!t10.isIdentifier(leftExpr)) {
              throw unexpectedType(path, leftExpr.type, "Identifier");
            }
            path.replaceWith(t10.variableDeclarator(leftExpr, rightExpr));
          } else {
            throw unexpectedType(path, expr.type, "Identifier | AssignmentExpression");
          }
        }
        path.replaceWith(t10.variableDeclaration("const", exprs));
      }
    }
    if (t10.isVariableDeclaration(body)) {
      body.kind = "const";
      path.replaceWith(body);
    }
    if (t10.isVariableDeclaration(path.node)) {
      path.traverse({
        VariableDeclarator(p) {
          if (p.parentPath === path) {
            const leftExpr = p.node.id;
            const rightExpr = p.node.init;
            variableExpression(state, p, leftExpr, rightExpr);
          }
        }
      });
    } else {
      throw unexpectedType(path, path.node.type, "VariableDeclaration");
    }
  };
}
function reactiveExpression(state, path) {
  const { body } = path.node;
  if (t10.isExpressionStatement(body)) {
    path.replaceWith(t10.callExpression(getHookIdentifier(state.hooks, path, "createEffect"), [
      t10.arrowFunctionExpression([], body.expression)
    ]));
  } else if (t10.isBlockStatement(body)) {
    path.replaceWith(t10.callExpression(getHookIdentifier(state.hooks, path, "createEffect"), [
      t10.arrowFunctionExpression([], body)
    ]));
  } else if (t10.isVariableDeclaration(body)) {
    body.kind = "const";
    path.replaceWith(body);
    path.traverse({
      VariableDeclarator(p) {
        const leftExpr = p.node.id;
        const rightExpr = p.node.init;
        if (t10.isIdentifier(leftExpr)) {
          memoVariableExpression(state, p, leftExpr, rightExpr != null ? rightExpr : t10.identifier("undefined"));
        }
      }
    });
  }
}
function createCallbackLabel(label, named = false) {
  return function expr(state, path) {
    let { body } = path.node;
    let name;
    let callback;
    if (named && t10.isLabeledStatement(body)) {
      name = body.label.name;
      body = body.body;
    }
    if (t10.isBlockStatement(body)) {
      callback = t10.arrowFunctionExpression([], body);
    } else if (t10.isExpressionStatement(body)) {
      callback = body.expression;
    } else {
      throw unexpectedType(path, body.type, "BlockStatement | ExpressionStatement");
    }
    if (name) {
      path.replaceWith(t10.callExpression(getHookIdentifier(state.hooks, path, label), [
        callback,
        t10.identifier("undefined"),
        t10.objectExpression([
          t10.objectProperty(t10.identifier("name"), t10.stringLiteral(name))
        ])
      ]));
    } else {
      path.replaceWith(t10.callExpression(getHookIdentifier(state.hooks, path, label), [
        callback
      ]));
    }
  };
}
var EXPRESSIONS = {
  $: reactiveExpression,
  signal: createVariableLabel((state, path, leftExpr, rightExpr) => {
    if (t10.isIdentifier(leftExpr)) {
      signalVariableExpression(state, path, leftExpr, rightExpr != null ? rightExpr : t10.identifier("undefined"));
    }
  }),
  memo: createVariableLabel((state, path, leftExpr, rightExpr) => {
    if (t10.isIdentifier(leftExpr)) {
      memoVariableExpression(state, path, leftExpr, rightExpr != null ? rightExpr : t10.identifier("undefined"));
    }
  }),
  deferred: createVariableLabel((state, path, leftExpr, rightExpr) => {
    if (t10.isIdentifier(leftExpr)) {
      deferredVariableExpression(state, path, leftExpr, rightExpr != null ? rightExpr : t10.identifier("undefined"));
    }
  }),
  destructure: createVariableLabel((state, path, leftExpr, rightExpr) => {
    if ((t10.isObjectPattern(leftExpr) || t10.isArrayPattern(leftExpr)) && rightExpr) {
      destructureVariableExpression(state, path, rightExpr, leftExpr);
    }
  }),
  children: createVariableLabel((state, path, leftExpr, rightExpr) => {
    if (t10.isIdentifier(leftExpr)) {
      accessorVariableExpression(state, path, leftExpr, "children", [
        t10.arrowFunctionExpression([], rightExpr != null ? rightExpr : t10.identifier("undefined"))
      ]);
    }
  }),
  effect: createCallbackLabel("createEffect", true),
  computed: createCallbackLabel("createComputed", true),
  renderEffect: createCallbackLabel("createRenderEffect", true),
  mount: createCallbackLabel("onMount"),
  cleanup: createCallbackLabel("onCleanup"),
  error: createCallbackLabel("onError"),
  root: createCallbackLabel("createRoot"),
  untrack: createCallbackLabel("untrack"),
  batch: createCallbackLabel("batch"),
  transition: createCallbackLabel("startTransition")
};
var LABEL_PARSER = {
  LabeledStatement(path, state) {
    if (path.node.label.name in EXPRESSIONS) {
      EXPRESSIONS[path.node.label.name](state, path);
    }
  }
};
var label_parser_default = LABEL_PARSER;

// src/comment-parser.ts
var t11 = __toModule(require("@babel/types"));
function signalExpression(state, path) {
  path.traverse({
    VariableDeclarator(p) {
      if (p.parentPath === path) {
        const leftExpr = p.node.id;
        const rightExpr = p.node.init;
        if (t11.isIdentifier(leftExpr)) {
          signalVariableExpression(state, p, leftExpr, rightExpr != null ? rightExpr : void 0);
        }
      }
    }
  });
}
function memoExpression(state, path) {
  path.traverse({
    VariableDeclarator(p) {
      if (p.parentPath === path) {
        const leftExpr = p.node.id;
        const rightExpr = p.node.init;
        if (t11.isIdentifier(leftExpr)) {
          memoVariableExpression(state, p, leftExpr, rightExpr != null ? rightExpr : t11.identifier("undefined"));
        }
      }
    }
  });
}
function destructureExpression(state, path) {
  path.traverse({
    VariableDeclarator(p) {
      if (p.parentPath === path) {
        const leftExpr = p.node.id;
        const rightExpr = p.node.init;
        if ((t11.isObjectPattern(leftExpr) || t11.isArrayPattern(leftExpr)) && rightExpr) {
          destructureVariableExpression(state, p, rightExpr, leftExpr);
        }
      }
    }
  });
}
function deferredExpression(state, path) {
  path.traverse({
    VariableDeclarator(p) {
      if (p.parentPath === path) {
        const leftExpr = p.node.id;
        const rightExpr = p.node.init;
        if (t11.isIdentifier(leftExpr)) {
          deferredVariableExpression(state, p, leftExpr, rightExpr != null ? rightExpr : t11.identifier("undefined"));
        }
      }
    }
  });
}
function childrenExpression(state, path) {
  path.traverse({
    VariableDeclarator(p) {
      if (p.parentPath === path) {
        const leftExpr = p.node.id;
        const rightExpr = p.node.init;
        if (t11.isIdentifier(leftExpr)) {
          accessorVariableExpression(state, p, leftExpr, "children", [
            t11.arrowFunctionExpression([], rightExpr != null ? rightExpr : t11.identifier("undefined"))
          ]);
        }
      }
    }
  });
}
function createCallbackLabel2(label, named = false) {
  return function expr(state, path, name) {
    const body = path.node;
    let callback;
    if (t11.isBlockStatement(body)) {
      callback = t11.arrowFunctionExpression([], body);
    } else {
      callback = body.expression;
    }
    if (named && name) {
      path.replaceWith(t11.callExpression(getHookIdentifier(state.hooks, path, label), [
        callback,
        t11.identifier("undefined"),
        t11.objectExpression([
          t11.objectProperty(t11.identifier("name"), t11.stringLiteral(name))
        ])
      ]));
    } else {
      path.replaceWith(t11.callExpression(getHookIdentifier(state.hooks, path, label), [
        callback
      ]));
    }
  };
}
var STATE_EXPRESSIONS = {
  "@signal": signalExpression,
  "@memo": memoExpression,
  "@children": childrenExpression,
  "@deferred": deferredExpression,
  "@destructure": destructureExpression
};
var CALLBACK_EXPRESSIONS = {
  "@effect": createCallbackLabel2("createEffect", true),
  "@computed": createCallbackLabel2("createComputed", true),
  "@renderEffect": createCallbackLabel2("createRenderEffect", true),
  "@mount": createCallbackLabel2("onMount"),
  "@cleanup": createCallbackLabel2("onCleanup"),
  "@error": createCallbackLabel2("onError"),
  "@root": createCallbackLabel2("createRoot"),
  "@untrack": createCallbackLabel2("untrack"),
  "@batch": createCallbackLabel2("batch"),
  "@transition": createCallbackLabel2("startTransition")
};
var COMMENT_PARSER = {
  VariableDeclaration(path, state) {
    const comments = path.node.leadingComments;
    if (comments) {
      let preference;
      for (let i = 0, len = comments.length; i < len; i += 1) {
        const comment = comments[i];
        const value = comment.value.trim();
        if (value in STATE_EXPRESSIONS) {
          preference = value;
          comment.value = "";
        }
      }
      if (preference) {
        STATE_EXPRESSIONS[preference](state, path);
      }
    }
  },
  BlockStatement(path, state) {
    if (t11.isFunctionDeclaration(path.parent)) {
      return;
    }
    const comments = path.node.leadingComments;
    if (comments) {
      let preference;
      let name;
      for (let i = 0, len = comments.length; i < len; i += 1) {
        const comment = comments[i];
        const value = comment.value.trim();
        if (/^@\w+( .*)?$/.test(value)) {
          const [tag, ...debugName] = value.split(" ");
          if (tag in CALLBACK_EXPRESSIONS) {
            preference = tag;
            name = debugName.join(" ");
            comment.value = "";
          }
        }
      }
      if (preference) {
        CALLBACK_EXPRESSIONS[preference](state, path, name);
      }
    }
  },
  ExpressionStatement(path, state) {
    const comments = path.node.leadingComments;
    if (comments) {
      let preference;
      let name;
      for (let i = 0, len = comments.length; i < len; i += 1) {
        const comment = comments[i];
        const value = comment.value.trim();
        if (/^@\w+( .*)?$/.test(value)) {
          const [tag, ...debugName] = value.split(" ");
          if (tag in CALLBACK_EXPRESSIONS) {
            preference = tag;
            name = debugName.join(" ");
            comment.value = "";
          }
        }
      }
      if (preference) {
        CALLBACK_EXPRESSIONS[preference](state, path, name);
      }
    }
  }
};
var comment_parser_default = COMMENT_PARSER;

// src/ctf-parser.ts
var t13 = __toModule(require("@babel/types"));

// src/deref-signal-variable.ts
var t12 = __toModule(require("@babel/types"));
function derefSignalVariableExpression(path, signalIdentifier, stateIdentifier) {
  const readIdentifier = path.scope.generateUidIdentifier(signalIdentifier.name);
  const writeIdentifier = path.scope.generateUidIdentifier(`set${signalIdentifier.name}`);
  path.node.id = t12.arrayPattern([
    readIdentifier,
    writeIdentifier
  ]);
  path.node.init = stateIdentifier;
  derefSignalExpression(path, signalIdentifier, readIdentifier, writeIdentifier);
}

// src/deref-memo-variable.ts
function derefMemoVariableExpression(path, memoIdentifier, stateIdentifier) {
  const readIdentifier = path.scope.generateUidIdentifier(memoIdentifier.name);
  path.node.id = readIdentifier;
  path.node.init = stateIdentifier;
  derefMemoExpression(path, memoIdentifier, readIdentifier);
}

// src/ctf-parser.ts
function derefSignalExpression2(_, path) {
  if (path.node.arguments.length > 1) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);
  }
  const argument = path.node.arguments[0];
  if (!t13.isExpression(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!t13.isVariableDeclarator(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!t13.isIdentifier(leftExpr)) {
    throw unexpectedType(path.parentPath, leftExpr.type, "Identifier");
  }
  derefSignalVariableExpression(path.parentPath, leftExpr, argument);
}
function signalExpression2(state, path) {
  if (path.node.arguments.length > 2) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 2);
  }
  let argument;
  let options;
  if (path.node.arguments.length > 0) {
    const initialState = path.node.arguments[0];
    if (!t13.isExpression(initialState)) {
      throw unexpectedType(path, initialState.type, "Expression");
    }
    argument = initialState;
    if (path.node.arguments.length > 1) {
      const optionsValue = path.node.arguments[1];
      if (!t13.isExpression(optionsValue)) {
        throw unexpectedType(path, optionsValue.type, "Expression");
      }
      options = optionsValue;
    }
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!t13.isVariableDeclarator(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!t13.isIdentifier(leftExpr)) {
    throw unexpectedType(path.parentPath, leftExpr.type, "Identifier");
  }
  signalVariableExpression(state, path.parentPath, leftExpr, argument, options);
}
function derefMemoExpression2(_, path) {
  if (path.node.arguments.length > 1) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);
  }
  const argument = path.node.arguments[0];
  if (!t13.isExpression(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!t13.isVariableDeclarator(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!t13.isIdentifier(leftExpr)) {
    throw unexpectedType(path.parentPath, leftExpr.type, "Expression");
  }
  derefMemoVariableExpression(path.parentPath, leftExpr, argument);
}
function memoExpression2(state, path) {
  if (path.node.arguments.length > 2) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 2);
  }
  const argument = path.node.arguments[0];
  if (!t13.isExpression(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  let options;
  if (path.node.arguments.length > 1) {
    const optionsValue = path.node.arguments[1];
    if (!t13.isExpression(optionsValue)) {
      throw unexpectedType(path, optionsValue.type, "Expression");
    }
    options = optionsValue;
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!t13.isVariableDeclarator(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!t13.isIdentifier(leftExpr)) {
    throw unexpectedType(path.parentPath, leftExpr.type, "Expression");
  }
  memoVariableExpression(state, path.parentPath, leftExpr, argument, options);
}
function deferredExpression2(state, path) {
  if (path.node.arguments.length > 2) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 2);
  }
  let argument;
  let options;
  if (path.node.arguments.length > 0) {
    const initialState = path.node.arguments[0];
    if (!t13.isExpression(initialState)) {
      throw unexpectedType(path, initialState.type, "Expression");
    }
    argument = initialState;
    if (path.node.arguments.length > 1) {
      const optionsValue = path.node.arguments[1];
      if (!t13.isExpression(optionsValue)) {
        throw unexpectedType(path, optionsValue.type, "Expression");
      }
      options = optionsValue;
    }
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!t13.isVariableDeclarator(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!t13.isIdentifier(leftExpr)) {
    throw unexpectedType(path, leftExpr.type, "Identifier");
  }
  deferredVariableExpression(state, path.parentPath, leftExpr, argument, options);
}
function reactiveExpression2(state, path) {
  if (path.node.arguments.length > 1) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);
  }
  const argument = path.node.arguments[0];
  if (!t13.isExpression(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (t13.isVariableDeclarator(path.parent)) {
    const leftExpr = path.parent.id;
    if (!t13.isIdentifier(leftExpr)) {
      throw unexpectedType(path, leftExpr.type, "Identifier");
    }
    memoVariableExpression(state, path.parentPath, leftExpr, argument);
  } else if (t13.isExpressionStatement(path.parent)) {
    path.replaceWith(t13.callExpression(getHookIdentifier(state.hooks, path, "createEffect"), [
      t13.arrowFunctionExpression([], argument)
    ]));
  } else {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator | ExpressionStatement");
  }
}
function rootExpression(state, path) {
  if (path.node.arguments.length > 1) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);
  }
  const argument = path.node.arguments[0];
  if (!t13.isExpression(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  const arrow = t13.isArrowFunctionExpression(argument) || t13.isFunctionExpression(argument) ? argument : t13.arrowFunctionExpression([], argument);
  path.replaceWith(t13.callExpression(getHookIdentifier(state.hooks, path, "createRoot"), [
    arrow
  ]));
}
function fromExpression(state, path) {
  if (path.node.arguments.length > 1) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);
  }
  const argument = path.node.arguments[0];
  if (!t13.isExpression(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!t13.isVariableDeclarator(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!t13.isIdentifier(leftExpr)) {
    throw unexpectedType(path, leftExpr.type, "Identifier");
  }
  accessorVariableExpression(state, path.parentPath, leftExpr, "from", [
    argument
  ]);
}
function createCompileTimeAutoAccessor(target, limit) {
  return (state, path) => {
    if (path.node.arguments.length > limit) {
      throw unexpectedArgumentLength(path, path.node.arguments.length, limit);
    }
    const [argument, ...rest] = path.node.arguments;
    if (!t13.isExpression(argument)) {
      throw unexpectedType(path, argument.type, "Expression");
    }
    if (!path.parentPath) {
      throw unexpectedMissingParent(path);
    }
    if (!t13.isVariableDeclarator(path.parent)) {
      throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
    }
    const leftExpr = path.parent.id;
    if (!t13.isIdentifier(leftExpr)) {
      throw unexpectedType(path, leftExpr.type, "Identifier");
    }
    accessorVariableExpression(state, path.parentPath, leftExpr, target, [
      normalizeAccessor(argument),
      ...rest
    ]);
  };
}
function createCompileTimeAlias(target, source) {
  return (state, path) => {
    path.node.callee = getHookIdentifier(state.hooks, path, target, source);
  };
}
function createCompileTimeAutoArrow(target, limit) {
  return (state, path) => {
    if (path.node.arguments.length > limit) {
      throw unexpectedArgumentLength(path, path.node.arguments.length, limit);
    }
    const [argument, ...rest] = path.node.arguments;
    if (!t13.isExpression(argument)) {
      throw unexpectedType(path, argument.type, "Expression");
    }
    path.replaceWith(t13.callExpression(getHookIdentifier(state.hooks, path, target), [
      normalizeAccessor(argument),
      ...rest
    ]));
  };
}
function destructureExpression2(state, path) {
  if (path.node.arguments.length > 1) {
    throw unexpectedArgumentLength(path, path.node.arguments.length, 1);
  }
  const argument = path.node.arguments[0];
  if (!t13.isExpression(argument)) {
    throw unexpectedType(path, argument.type, "Expression");
  }
  if (!path.parentPath) {
    throw unexpectedMissingParent(path);
  }
  if (!t13.isVariableDeclarator(path.parent)) {
    throw unexpectedType(path.parentPath, path.parent.type, "VariableDeclarator");
  }
  const leftExpr = path.parent.id;
  if (!(t13.isObjectPattern(leftExpr) || t13.isArrayPattern(leftExpr))) {
    throw unexpectedType(path, leftExpr.type, "ArrayPattern | ObjectPattern");
  }
  destructureVariableExpression(state, path.parentPath, argument, leftExpr);
}
var CTF_EXPRESSIONS = {
  $: reactiveExpression2,
  $derefSignal: derefSignalExpression2,
  $derefMemo: derefMemoExpression2,
  $signal: signalExpression2,
  $memo: memoExpression2,
  $root: rootExpression,
  $from: fromExpression,
  $deferred: deferredExpression2,
  $children: createCompileTimeAutoAccessor("children", 1),
  $mapArray: createCompileTimeAutoAccessor("mapArray", 3),
  $indexArray: createCompileTimeAutoAccessor("indexArray", 3),
  $lazy: createCompileTimeAutoArrow("lazy", 1),
  $untrack: createCompileTimeAutoArrow("untrack", 1),
  $batch: createCompileTimeAutoArrow("batch", 1),
  $observable: createCompileTimeAutoArrow("observable", 1),
  $selector: createCompileTimeAutoArrow("createSelector", 1),
  $on: createCompileTimeAutoArrow("on", 3),
  $useContext: createCompileTimeAlias("useContext"),
  $createContext: createCompileTimeAlias("createContext"),
  $uid: createCompileTimeAlias("createUniqueId"),
  $effect: createCompileTimeAlias("createEffect"),
  $computed: createCompileTimeAlias("createComputed"),
  $renderEffect: createCompileTimeAlias("createRenderEffect"),
  $merge: createCompileTimeAlias("mergeProps"),
  $resource: createCompileTimeAlias("createResource"),
  $store: createCompileTimeAlias("createStore", "solid-js/store"),
  $mutable: createCompileTimeAlias("createMutable", "solid-js/store"),
  $produce: createCompileTimeAlias("produce", "solid-js/store"),
  $reconcile: createCompileTimeAlias("reconcile", "solid-js/store"),
  $destructure: destructureExpression2
};
var CTF_PARSER = {
  CallExpression(path, state) {
    if (t13.isIdentifier(path.node.callee) && path.node.callee.name in CTF_EXPRESSIONS && !path.scope.hasBinding(path.node.callee.name)) {
      CTF_EXPRESSIONS[path.node.callee.name](state, path);
    }
  }
};
var ctf_parser_default = CTF_PARSER;

// src/auto-import.ts
var t14 = __toModule(require("@babel/types"));
function createAutoImport(target, source) {
  return (state, path) => {
    path.replaceWith(getHookIdentifier(state.hooks, path, target, source));
  };
}
var AUTO_IMPORT_EXPR = {
  $for: createAutoImport("For"),
  $show: createAutoImport("Show"),
  $switch: createAutoImport("Switch"),
  $match: createAutoImport("Match"),
  $index: createAutoImport("Index"),
  $errorBoundary: createAutoImport("ErrorBoundary"),
  $suspense: createAutoImport("Suspense"),
  $suspenseList: createAutoImport("SuspenseList"),
  $dynamic: createAutoImport("Dynamic", "solid-js/web"),
  $portal: createAutoImport("Portal", "solid-js/web"),
  $assets: createAutoImport("Assets", "solid-js/web"),
  $hydrationScript: createAutoImport("HydrationScript", "solid-js/web"),
  $noHydration: createAutoImport("NoHydration", "solid-js/web")
};
var AUTO_IMPORT = {
  Expression(p, state) {
    if (t14.isIdentifier(p.node) && !p.scope.hasBinding(p.node.name) && p.node.name in AUTO_IMPORT_EXPR) {
      AUTO_IMPORT_EXPR[p.node.name](state, p);
    }
  }
};
var auto_import_default = AUTO_IMPORT;

// src/index.ts
function solidReactivityPlugin() {
  return {
    pre() {
      this.hooks = new Map();
    },
    visitor: __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, label_parser_default), comment_parser_default), ctf_parser_default), auto_import_default)
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map
